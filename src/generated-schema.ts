/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/clusters": {
    /** Get available clusters */
    get: operations["getClusters"];
  };
  "/secrets": {
    /** Get all secrets */
    get: operations["getAllSecrets"];
  };
  "/services": {
    /** Get all services running on the cluster */
    get: operations["getAllServices"];
  };
  "/teams": {
    /** Get teams collection */
    get: operations["getTeams"];
    /** Create a team */
    post: operations["createTeam"];
  };
  "/teams/{teamId}": {
    /** Get a specific team */
    get: operations["getTeam"];
    /** Edit a team */
    put: operations["editTeam"];
    /** Delete team */
    delete: operations["deleteTeam"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/teams/{teamId}/services": {
    /** Get services from a given team */
    get: operations["getTeamServices"];
    /** Create a service */
    post: operations["createService"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/teams/{teamId}/services/{serviceId}": {
    /** Get a service from a given team */
    get: operations["getService"];
    /** Edit a service from a given team */
    put: operations["editService"];
    /** Delete a service from a given team */
    delete: operations["deleteService"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
  };
  "/teams/{teamId}/secrets": {
    /** Get secrets from a given team */
    get: operations["getSecrets"];
    /** Create a team secret */
    post: operations["createSecret"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/teams/{teamId}/secrets/{secretId}": {
    /** Get a secret from a given team */
    get: operations["getSecret"];
    /** Edit a secret from a given team */
    put: operations["editSecret"];
    /** Delete a secret from a given team */
    delete: operations["deleteSecret"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
  };
  "/deploy": {
    /** Trigger a deployment (only for admin) */
    get: operations["deploy"];
  };
  "/kubecfg/{teamId}": {
    /** Download a kubecfg for a team */
    get: operations["downloadKubecfg"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/session": {
    /** Get the session for the current user */
    get: operations["getSession"];
  };
  "/apiDocs": {
    /** Get OpenAPIDoc document */
    get: operations["apiDocs"];
  };
  "/settings": {
    /** Get settings from the `settings.yaml` and `secret.settings.yaml` file. */
    get: operations["getSettings"];
    /** Edits the settings from the `settings.yaml` file */
    put: operations["editSettings"];
  };
}

export interface components {
  schemas: {
    Cluster: {
      /** Only used for API/UI to show in app. */
      apiName?: string;
      /** Used by kubectl for local deployment to target cluster. */
      apiServer: string;
      /** A Kubernetes API public IP address (onprem only). */
      entrypoint?: string;
      /** The cluster k8s version. Otomi supports 2 minor versions backwards compatibility from the suggested default. */
      k8sVersion: "1.17" | "1.18" | "1.19";
      name: string;
      /** Please pin this a valid release version found in the repo. Suggestion: try the most recent stable version. */
      otomiVersion: string;
      provider: "aws" | "azure" | "google" | "oneprem";
      /** Dependent on provider. */
      region: string;
      /** AWS only. If provided will override autodiscovery from metadata. */
      vpcID?: string;
    };
    Deployment: {
      id?: number;
      /** Deployment status */
      status?: "in-progress" | "completed" | "failed";
    };
    Kubecfg: { [key: string]: any };
    OpenApiValidationError: {
      status?: number;
      errors?: {
        path?: string;
        errorCode?: string;
        message?: string;
        location?: "body" | "path";
      }[];
    };
    OtomiStackError: {
      message?: string;
    };
    Secret: (
      | {
          type: "generic";
          entries: string[];
        }
      | {
          type: "docker-registry";
          dockerconfig?: ".dockerconfig.json";
        }
      | {
          type: "tls";
          /** A Vault property name that contains PEM public key certificate */
          crt: string;
          /** A Vault property name that contains PEM private key certificate */
          key: string;
          /** A Vault property name that contains CA certificate content */
          ca?: string;
        }
    ) & {
      id?: string;
      /** A secret name */
      name: string;
    };
    Service: {
      enabled?: boolean;
      id?: string;
      /** A service name */
      name: string;
      /** A service port */
      port?: number;
      ksvc?:
        | ({
            /** Kubernetes annotations with arbitrary metadata */
            annotations?: {
              name?: string;
              value?: string;
            }[];
            /** Deploys new images based on a tagging strategy */
            autoCD?:
              | ({ [key: string]: any } | null)
              | ({
                  /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                  semver: string;
                  tagMatcher?: "semver";
                } | null)
              | {
                  /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                  glob: string;
                  tagMatcher?: "glob";
                };
            env?:
              | {
                  name: string;
                  value: string;
                }[]
              | null;
            image?: {
              /** A container image repository. */
              repository: string;
              tag: string;
            } | null;
            /** Compute resources for containers. */
            resources?: {
              /** Requested resources (best effort). */
              limits?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
              /** Requested resources (guaranteed). */
              requests?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
            };
            /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
            scaleToZero?: boolean;
            secrets?: {
              name: string;
              entries?: string[];
            }[];
            serviceType?: "ksvc";
          } | null)
        | {
            serviceType: "ksvcPredeployed";
          }
        | {
            serviceType: "svcPredeployed";
          };
      ingress?:
        | ({ [key: string]: any } | null)
        | {
            /** Use the team domain so that the URL reveals the owner. */
            useDefaultSubdomain?: boolean;
            /** A host that is used to set DNS 'A' records */
            subdomain: string | null;
            /** A managed DNS zone */
            domain: string;
            /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
            path?: string;
            /** Forward the URL path into the service (don't rewrite to /) */
            forwardPath?: boolean;
            hasSingleSignOn?: boolean;
            /** If true a certificate should exist already */
            hasCert?: boolean;
            certArn?: string;
            certSelect?: boolean;
            certName?: string;
          };
      teamId: string;
    };
    Session: {
      cluster?: {
        /** Only used for API/UI to show in app. */
        apiName?: string;
        /** Used by kubectl for local deployment to target cluster. */
        apiServer: string;
        /** A Kubernetes API public IP address (onprem only). */
        entrypoint?: string;
        /** The cluster k8s version. Otomi supports 2 minor versions backwards compatibility from the suggested default. */
        k8sVersion: "1.17" | "1.18" | "1.19";
        name: string;
        /** Please pin this a valid release version found in the repo. Suggestion: try the most recent stable version. */
        otomiVersion: string;
        provider: "aws" | "azure" | "google" | "oneprem";
        /** Dependent on provider. */
        region: string;
        /** AWS only. If provided will override autodiscovery from metadata. */
        vpcID?: string;
      };
      dns?: { [key: string]: any };
      core?: { [key: string]: any };
      isDirty?: boolean;
      namespaces?: string[];
      teams?: {
        id?: string;
        /** A team name */
        name: string;
        oidc?: {
          /** An OIDC group name/id granting access to this team */
          groupMapping?: string;
        };
        password?: string;
        alerts?: {
          email?: {
            /** Email addresses (comma separated) for critical events. */
            critical?: string;
            /** One or more email addresses (comma separated) for non-critical events. */
            nonCritical?: string;
          };
          msteams?: {
            /** The high prio web hook */
            highPrio?: string;
            /** The low prio web hook */
            lowPrio?: string;
          };
          receivers?: ("slack" | "msteams" | "email")[];
          slack?: {
            /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
            channel?: string;
            /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
            channelCrit?: string;
            /** Slack web hook. If none is given the global one is used. */
            url?: string;
          };
        };
      }[];
      user?: {
        /** A user name */
        name: string;
        email: string;
        /** If the user is admin */
        isAdmin: boolean;
        /** A list of teams the user belongs to */
        teams: string[];
        /** A list of roles that the user has */
        roles: string[];
      };
    };
    Settings: {
      alerts?: {
        drone?: "slack" | "msteams";
        email?: {
          /** One or more email addresses (comma separated) for critical events. */
          critical?: string;
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
        };
        /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
        groupInterval?: string;
        msteams?: {
          /** The low prio web hook. */
          highPrio?: string;
          /** The high prio web hook. */
          lowPrio?: string;
        };
        /** Notification receivers. */
        receivers?: ("slack" | "msteams" | "email")[];
        /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
        repeatInterval?: string;
        slack?: {
          /** The Slack channel for non-critical notifications. */
          channel?: string;
          /** The Slack channel for critical notifications. */
          channelCrit?: string;
          /** A Slack webhook URL. */
          url?: string;
        };
      };
      /** Azure specific configuration. */
      azure?: {
        appgw?: {
          /** Is this appgw installed as AKS addon? */
          isManaged?: boolean;
        };
        /** An Azure disk type (SKU Type). */
        diskType:
          | "Standard_LRS"
          | "Standard_GRS"
          | "Standard_RAGRS"
          | "Standard_ZRS"
          | "Premium_LRS"
          | "Premium_ZRS"
          | "Standard_GZRS"
          | "Standard_RAGZRS";
        /** Azure Key Vault access credentials. Will use azure.tenantId if tenantId is not provided. */
        keyVault?: {
          /** An Azure tenant ID. */
          tenantId?: string;
          /** An Azure client ID. */
          clientId: string;
          /** An Azure client secret. */
          clientSecret: string;
        };
        monitor?: {
          /** An Azure AppInsights client secret (defaults to clientSecret). */
          appInsightsApiKey?: string;
          /** An Azure AppInsights client id (defaults to clientId). */
          appInsightsAppId?: string;
          /** An Azure client id. */
          clientId?: string;
          /** An Azure client secret. */
          clientSecret?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientId?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientSecret?: string;
          /** An Azure tenant id (defaults to tenantId). */
          logAnalyticsTenantId?: string;
          /** An Azure monitor log analytics workspace. */
          logAnalyticsWorkspace?: string;
        };
        /** An Azure resource group. */
        resourceGroup: string;
        /** An Azure subscription ID. */
        subscriptionId: string;
        /** An Azure tenant ID. */
        tenantId: string;
      };
      customer?: {
        name?: string;
      };
      /** Google specific configuration. */
      google?: {
        /** A service account key for managing a DNS zone. */
        cloudDnsKey: string;
        /** A service account key for managing a KMS vault. */
        kmsAccount?: string;
        /** A Google Cloud project ID for accessing DNS zone. */
        projectId: string;
      };
      dns?: (
        | {
            aws: {
              region: string;
            };
          }
        | {
            azure: {
              /** Azure Cloud to use */
              cloud?: string;
              /** Azure resource group to use */
              resourceGroup: string;
              hostedZoneName?: string;
              /** Azure tenant ID to use (will default to global value) */
              tenantId: string;
              /** Azure subscription ID to use (will default to global value) */
              subscriptionId: string;
              /** Azure Application Client ID to use */
              aadClientId: string;
              /** Azure Application Client Secret to use */
              aadClientSecret: string;
              /** If you use Azure MSI, this should be set to true */
              useManagedIdentityExtension?: boolean;
            };
          }
        | {
            google: {
              /** A service account key for managing a DNS zone. */
              serviceAccountKey: string;
              project: string;
            };
          }
      ) & {
        /** Extra dns zones that the cluster can administer (see dns). Team services can use this to publish their URLs on. */
        dnsZones?: string[];
        /** A fqdn for the cluster */
        domain: string;
      };
      home?: {
        drone?: "slack" | "msteams";
        email?: {
          /** One or more email addresses (comma separated) for critical events. */
          critical?: string;
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
        };
        /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
        groupInterval?: string;
        msteams?: {
          /** The low prio web hook. */
          highPrio?: string;
          /** The high prio web hook. */
          lowPrio?: string;
        };
        /** Notification receivers. */
        receivers?: ("slack" | "msteams" | "email")[];
        /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
        repeatInterval?: string;
        slack?: {
          /** The Slack channel for non-critical notifications. */
          channel?: string;
          /** The Slack channel for critical notifications. */
          channelCrit?: string;
          /** A Slack webhook URL. */
          url?: string;
        };
      };
      /** Use Cloud KMS to encrypt and decrypt the master key */
      kms?:
        | {
            gcpckms: {
              project: string;
              region: string;
              key_ring: string;
              kmsAccount: string;
            };
          }
        | {
            awskms: {
              region: string;
              access_key: string;
              secret_key: string;
              endpoint: string;
            };
          }
        | {
            azurekeyvault: {
              vault_name: string;
              tenant_id: string;
              client_id: string;
              client_secret: string;
            };
          };
      /** Holds many parts used in different locations. Please see keycloak, istio and oauth-proxy all consuming parts. */
      oidc?: {
        adminGroupID?: string;
        apiUrl?: string;
        authUrl?: string;
        clientID?: string;
        clientSecret?: string;
        issuer?: string;
        scope?: string;
        teamAdminGroupID?: string;
        tenantID?: string;
        tokenUrl?: string;
        /** Claim name used by Keycloak to identify incoming users from identity provider */
        usernameClaimMapper?: string;
        /** Select OIDC claim to be used as a unique user identifier */
        subClaimMapper?: string;
      };
      otomi?: {
        /** Set this to true when an external LB exists or needs to be started (AWS ALB, Azure AppGW, Google Apigee). This will then be configured through ingress controllers. Expects existing LBs to terminate https. Currently this is only working correctly for Azure, and not for AWS and Google. AWS is close to completion. */
        hasCloudLB?: boolean;
        /** Whether this cluster is home monitored (like when under a Premium SLA). Sends criticals home. */
        isHomeMonitored?: boolean;
        /** Whether masters are managed and not under control. Set this to false when onprem. */
        isManaged?: boolean;
        /** Whether to separate team metrics and logs. Disabling this lets everybody be admin and see everything. */
        isMultitenant?: boolean;
        /** The otomi-core edition. Either community edition (ce) or enterprise edition (ee). */
        mode?: "ce" | "ee";
        /** The pullsecret to deploy the Otomi API and Console. Requires an Otomi license. */
        pullSecret?: string;
        /** The prefix to use in URLs for team domains. */
        teamPrefix?: string;
        /** Manage addon configuration */
        addons?: {
          conftest?: {
            /** Use this flag to enable conftest for policy validation */
            enabled?: boolean;
          };
        };
      };
      smtp?: {
        auth_identity?: string;
        auth_password?: string;
        auth_secret?: string;
        auth_username?: string;
        /** The "from" address. Defaults to alerts@$clusterDomain. */
        from?: string;
        hello?: string;
        /** The smtp host:port combination. */
        smarthost: string;
      };
    };
    Team: {
      id?: string;
      /** A team name */
      name: string;
      oidc?: {
        /** An OIDC group name/id granting access to this team */
        groupMapping?: string;
      };
      password?: string;
      alerts?: {
        email?: {
          /** Email addresses (comma separated) for critical events. */
          critical?: string;
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
        };
        msteams?: {
          /** The high prio web hook */
          highPrio?: string;
          /** The low prio web hook */
          lowPrio?: string;
        };
        receivers?: ("slack" | "msteams" | "email")[];
        slack?: {
          /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
          channel?: string;
          /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
          channelCrit?: string;
          /** Slack web hook. If none is given the global one is used. */
          url?: string;
        };
      };
    };
    User: {
      /** A user name */
      name: string;
      email: string;
      /** If the user is admin */
      isAdmin: boolean;
      /** A list of teams the user belongs to */
      teams: string[];
      /** A list of roles that the user has */
      roles: string[];
    };
  };
  parameters: {
    /** ID of team to return */
    teamParams: string;
    /** ID of the service */
    serviceParams: string;
    /** ID of the secret */
    secretParams: string;
  };
}

export interface operations {
  /** Get available clusters */
  getClusters: {
    responses: {
      /** Successfully obtained cluster collection */
      200: {
        content: {
          "application/json": {
            /** Only used for API/UI to show in app. */
            apiName?: string;
            /** Used by kubectl for local deployment to target cluster. */
            apiServer: string;
            /** A Kubernetes API public IP address (onprem only). */
            entrypoint?: string;
            /** The cluster k8s version. Otomi supports 2 minor versions backwards compatibility from the suggested default. */
            k8sVersion: "1.17" | "1.18" | "1.19";
            name: string;
            /** Please pin this a valid release version found in the repo. Suggestion: try the most recent stable version. */
            otomiVersion: string;
            provider: "aws" | "azure" | "google" | "oneprem";
            /** Dependent on provider. */
            region: string;
            /** AWS only. If provided will override autodiscovery from metadata. */
            vpcID?: string;
          }[];
        };
      };
    };
  };
  /** Get all secrets */
  getAllSecrets: {
    responses: {
      /** Successfully obtained all secrets */
      200: {
        content: {
          "application/json": ((
            | {
                type: "generic";
                entries: string[];
              }
            | {
                type: "docker-registry";
                dockerconfig?: ".dockerconfig.json";
              }
            | {
                type: "tls";
                /** A Vault property name that contains PEM public key certificate */
                crt: string;
                /** A Vault property name that contains PEM private key certificate */
                key: string;
                /** A Vault property name that contains CA certificate content */
                ca?: string;
              }
          ) & {
            id?: string;
            /** A secret name */
            name: string;
          })[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Get all services running on the cluster */
  getAllServices: {
    responses: {
      /** Successfully obtained all services */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A service port */
            port?: number;
            ksvc?:
              | ({
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                        tagMatcher?: "semver";
                      } | null)
                    | {
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                        tagMatcher?: "glob";
                      };
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  /** Compute resources for containers. */
                  resources?: {
                    /** Requested resources (best effort). */
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    /** Requested resources (guaranteed). */
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  };
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  serviceType?: "ksvc";
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          }[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Get teams collection */
  getTeams: {
    responses: {
      /** Successfully obtained teams collection */
      200: {
        content: {
          "application/json": {
            id?: string;
            /** A team name */
            name: string;
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password?: string;
            alerts?: {
              email?: {
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
              };
              msteams?: {
                /** The high prio web hook */
                highPrio?: string;
                /** The low prio web hook */
                lowPrio?: string;
              };
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
              };
            };
          }[];
        };
      };
    };
  };
  /** Create a team */
  createTeam: {
    responses: {
      /** Successfully obtained teams collection */
      200: {
        content: {
          "application/json": {
            id?: string;
            /** A team name */
            name: string;
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password?: string;
            alerts?: {
              email?: {
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
              };
              msteams?: {
                /** The high prio web hook */
                highPrio?: string;
                /** The low prio web hook */
                lowPrio?: string;
              };
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
              };
            };
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Team object that needs to be added to the collection */
    requestBody: {
      content: {
        "application/json": {
          id?: string;
          /** A team name */
          name: string;
          oidc?: {
            /** An OIDC group name/id granting access to this team */
            groupMapping?: string;
          };
          password?: string;
          alerts?: {
            email?: {
              /** Email addresses (comma separated) for critical events. */
              critical?: string;
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
            };
            msteams?: {
              /** The high prio web hook */
              highPrio?: string;
              /** The low prio web hook */
              lowPrio?: string;
            };
            receivers?: ("slack" | "msteams" | "email")[];
            slack?: {
              /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
              channel?: string;
              /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
              channelCrit?: string;
              /** Slack web hook. If none is given the global one is used. */
              url?: string;
            };
          };
        };
      };
    };
  };
  /** Get a specific team */
  getTeam: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully obtained team */
      200: {
        content: {
          "application/json": {
            id?: string;
            /** A team name */
            name: string;
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password?: string;
            alerts?: {
              email?: {
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
              };
              msteams?: {
                /** The high prio web hook */
                highPrio?: string;
                /** The low prio web hook */
                lowPrio?: string;
              };
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
              };
            };
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Edit a team */
  editTeam: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully edited team */
      200: {
        content: {
          "application/json": {
            id?: string;
            /** A team name */
            name: string;
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password?: string;
            alerts?: {
              email?: {
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
              };
              msteams?: {
                /** The high prio web hook */
                highPrio?: string;
                /** The low prio web hook */
                lowPrio?: string;
              };
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
              };
            };
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Team object that contains updated values */
    requestBody: {
      content: {
        "application/json": {
          id?: string;
          /** A team name */
          name: string;
          oidc?: {
            /** An OIDC group name/id granting access to this team */
            groupMapping?: string;
          };
          password?: string;
          alerts?: {
            email?: {
              /** Email addresses (comma separated) for critical events. */
              critical?: string;
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
            };
            msteams?: {
              /** The high prio web hook */
              highPrio?: string;
              /** The low prio web hook */
              lowPrio?: string;
            };
            receivers?: ("slack" | "msteams" | "email")[];
            slack?: {
              /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
              channel?: string;
              /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
              channelCrit?: string;
              /** Slack web hook. If none is given the global one is used. */
              url?: string;
            };
          };
        };
      };
    };
  };
  /** Delete team */
  deleteTeam: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully deleted a team */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Get services from a given team */
  getTeamServices: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully obtained services */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A service port */
            port?: number;
            ksvc?:
              | ({
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                        tagMatcher?: "semver";
                      } | null)
                    | {
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                        tagMatcher?: "glob";
                      };
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  /** Compute resources for containers. */
                  resources?: {
                    /** Requested resources (best effort). */
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    /** Requested resources (guaranteed). */
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  };
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  serviceType?: "ksvc";
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          }[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Create a service */
  createService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully stored service configuration */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A service port */
            port?: number;
            ksvc?:
              | ({
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                        tagMatcher?: "semver";
                      } | null)
                    | {
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                        tagMatcher?: "glob";
                      };
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  /** Compute resources for containers. */
                  resources?: {
                    /** Requested resources (best effort). */
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    /** Requested resources (guaranteed). */
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  };
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  serviceType?: "ksvc";
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Service object */
    requestBody: {
      content: {
        "application/json": {
          enabled?: boolean;
          id?: string;
          /** A service name */
          name: string;
          /** A service port */
          port?: number;
          ksvc?:
            | ({
                /** Kubernetes annotations with arbitrary metadata */
                annotations?: {
                  name?: string;
                  value?: string;
                }[];
                /** Deploys new images based on a tagging strategy */
                autoCD?:
                  | ({ [key: string]: any } | null)
                  | ({
                      /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                      semver: string;
                      tagMatcher?: "semver";
                    } | null)
                  | {
                      /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                      glob: string;
                      tagMatcher?: "glob";
                    };
                env?:
                  | {
                      name: string;
                      value: string;
                    }[]
                  | null;
                image?: {
                  /** A container image repository. */
                  repository: string;
                  tag: string;
                } | null;
                /** Compute resources for containers. */
                resources?: {
                  /** Requested resources (best effort). */
                  limits?: {
                    /** Amount of cores, or slice of cpu in millis. */
                    cpu: string;
                    /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                    memory: string;
                  };
                  /** Requested resources (guaranteed). */
                  requests?: {
                    /** Amount of cores, or slice of cpu in millis. */
                    cpu: string;
                    /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                    memory: string;
                  };
                };
                /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                scaleToZero?: boolean;
                secrets?: {
                  name: string;
                  entries?: string[];
                }[];
                serviceType?: "ksvc";
              } | null)
            | {
                serviceType: "ksvcPredeployed";
              }
            | {
                serviceType: "svcPredeployed";
              };
          ingress?:
            | ({ [key: string]: any } | null)
            | {
                /** Use the team domain so that the URL reveals the owner. */
                useDefaultSubdomain?: boolean;
                /** A host that is used to set DNS 'A' records */
                subdomain: string | null;
                /** A managed DNS zone */
                domain: string;
                /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                path?: string;
                /** Forward the URL path into the service (don't rewrite to /) */
                forwardPath?: boolean;
                hasSingleSignOn?: boolean;
                /** If true a certificate should exist already */
                hasCert?: boolean;
                certArn?: string;
                certSelect?: boolean;
                certName?: string;
              };
          teamId: string;
        };
      };
    };
  };
  /** Get a service from a given team */
  getService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
    responses: {
      /** Successfully obtained service configuration */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A service port */
            port?: number;
            ksvc?:
              | ({
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                        tagMatcher?: "semver";
                      } | null)
                    | {
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                        tagMatcher?: "glob";
                      };
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  /** Compute resources for containers. */
                  resources?: {
                    /** Requested resources (best effort). */
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    /** Requested resources (guaranteed). */
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  };
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  serviceType?: "ksvc";
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Edit a service from a given team */
  editService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
    responses: {
      /** Successfully edited service */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A service port */
            port?: number;
            ksvc?:
              | ({
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                        tagMatcher?: "semver";
                      } | null)
                    | {
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                        tagMatcher?: "glob";
                      };
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  /** Compute resources for containers. */
                  resources?: {
                    /** Requested resources (best effort). */
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    /** Requested resources (guaranteed). */
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  };
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  serviceType?: "ksvc";
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Service object that contains updated values */
    requestBody: {
      content: {
        "application/json": {
          enabled?: boolean;
          id?: string;
          /** A service name */
          name: string;
          /** A service port */
          port?: number;
          ksvc?:
            | ({
                /** Kubernetes annotations with arbitrary metadata */
                annotations?: {
                  name?: string;
                  value?: string;
                }[];
                /** Deploys new images based on a tagging strategy */
                autoCD?:
                  | ({ [key: string]: any } | null)
                  | ({
                      /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                      semver: string;
                      tagMatcher?: "semver";
                    } | null)
                  | {
                      /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                      glob: string;
                      tagMatcher?: "glob";
                    };
                env?:
                  | {
                      name: string;
                      value: string;
                    }[]
                  | null;
                image?: {
                  /** A container image repository. */
                  repository: string;
                  tag: string;
                } | null;
                /** Compute resources for containers. */
                resources?: {
                  /** Requested resources (best effort). */
                  limits?: {
                    /** Amount of cores, or slice of cpu in millis. */
                    cpu: string;
                    /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                    memory: string;
                  };
                  /** Requested resources (guaranteed). */
                  requests?: {
                    /** Amount of cores, or slice of cpu in millis. */
                    cpu: string;
                    /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                    memory: string;
                  };
                };
                /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                scaleToZero?: boolean;
                secrets?: {
                  name: string;
                  entries?: string[];
                }[];
                serviceType?: "ksvc";
              } | null)
            | {
                serviceType: "ksvcPredeployed";
              }
            | {
                serviceType: "svcPredeployed";
              };
          ingress?:
            | ({ [key: string]: any } | null)
            | {
                /** Use the team domain so that the URL reveals the owner. */
                useDefaultSubdomain?: boolean;
                /** A host that is used to set DNS 'A' records */
                subdomain: string | null;
                /** A managed DNS zone */
                domain: string;
                /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                path?: string;
                /** Forward the URL path into the service (don't rewrite to /) */
                forwardPath?: boolean;
                hasSingleSignOn?: boolean;
                /** If true a certificate should exist already */
                hasCert?: boolean;
                certArn?: string;
                certSelect?: boolean;
                certName?: string;
              };
          teamId: string;
        };
      };
    };
  };
  /** Delete a service from a given team */
  deleteService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
    responses: {
      /** Successfully deleted a service */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Get secrets from a given team */
  getSecrets: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully obtained secrets */
      200: {
        content: {
          "application/json": ((
            | {
                type: "generic";
                entries: string[];
              }
            | {
                type: "docker-registry";
                dockerconfig?: ".dockerconfig.json";
              }
            | {
                type: "tls";
                /** A Vault property name that contains PEM public key certificate */
                crt: string;
                /** A Vault property name that contains PEM private key certificate */
                key: string;
                /** A Vault property name that contains CA certificate content */
                ca?: string;
              }
          ) & {
            id?: string;
            /** A secret name */
            name: string;
          })[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Create a team secret */
  createSecret: {
    parameters: {
      path: {
        /** ID of team */
        teamId: string;
      };
    };
    responses: {
      /** Successfully stored secret configuration */
      200: {
        content: {
          "application/json": (
            | {
                type: "generic";
                entries: string[];
              }
            | {
                type: "docker-registry";
                dockerconfig?: ".dockerconfig.json";
              }
            | {
                type: "tls";
                /** A Vault property name that contains PEM public key certificate */
                crt: string;
                /** A Vault property name that contains PEM private key certificate */
                key: string;
                /** A Vault property name that contains CA certificate content */
                ca?: string;
              }
          ) & {
            id?: string;
            /** A secret name */
            name: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Service object */
    requestBody: {
      content: {
        "application/json": (
          | {
              type: "generic";
              entries: string[];
            }
          | {
              type: "docker-registry";
              dockerconfig?: ".dockerconfig.json";
            }
          | {
              type: "tls";
              /** A Vault property name that contains PEM public key certificate */
              crt: string;
              /** A Vault property name that contains PEM private key certificate */
              key: string;
              /** A Vault property name that contains CA certificate content */
              ca?: string;
            }
        ) & {
          id?: string;
          /** A secret name */
          name: string;
        };
      };
    };
  };
  /** Get a secret from a given team */
  getSecret: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
    responses: {
      /** Successfully obtained secret configuration */
      200: {
        content: {
          "application/json": (
            | {
                type: "generic";
                entries: string[];
              }
            | {
                type: "docker-registry";
                dockerconfig?: ".dockerconfig.json";
              }
            | {
                type: "tls";
                /** A Vault property name that contains PEM public key certificate */
                crt: string;
                /** A Vault property name that contains PEM private key certificate */
                key: string;
                /** A Vault property name that contains CA certificate content */
                ca?: string;
              }
          ) & {
            id?: string;
            /** A secret name */
            name: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Edit a secret from a given team */
  editSecret: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
    responses: {
      /** Successfully edited a team secret */
      200: {
        content: {
          "application/json": (
            | {
                type: "generic";
                entries: string[];
              }
            | {
                type: "docker-registry";
                dockerconfig?: ".dockerconfig.json";
              }
            | {
                type: "tls";
                /** A Vault property name that contains PEM public key certificate */
                crt: string;
                /** A Vault property name that contains PEM private key certificate */
                key: string;
                /** A Vault property name that contains CA certificate content */
                ca?: string;
              }
          ) & {
            id?: string;
            /** A secret name */
            name: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Secret object that contains updated values */
    requestBody: {
      content: {
        "application/json": (
          | {
              type: "generic";
              entries: string[];
            }
          | {
              type: "docker-registry";
              dockerconfig?: ".dockerconfig.json";
            }
          | {
              type: "tls";
              /** A Vault property name that contains PEM public key certificate */
              crt: string;
              /** A Vault property name that contains PEM private key certificate */
              key: string;
              /** A Vault property name that contains CA certificate content */
              ca?: string;
            }
        ) & {
          id?: string;
          /** A secret name */
          name: string;
        };
      };
    };
  };
  /** Delete a secret from a given team */
  deleteSecret: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
    responses: {
      /** Successfully deleted a team secret */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Trigger a deployment (only for admin) */
  deploy: {
    responses: {
      /** Deployment has been triggered */
      202: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Download a kubecfg for a team */
  downloadKubecfg: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Succesfully finished the download */
      200: {
        content: {
          "application/yaml": { [key: string]: any };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Get the session for the current user */
  getSession: {
    responses: {
      /** Get the session for the logged in user */
      200: {
        content: {
          "application/json": {
            cluster?: {
              /** Only used for API/UI to show in app. */
              apiName?: string;
              /** Used by kubectl for local deployment to target cluster. */
              apiServer: string;
              /** A Kubernetes API public IP address (onprem only). */
              entrypoint?: string;
              /** The cluster k8s version. Otomi supports 2 minor versions backwards compatibility from the suggested default. */
              k8sVersion: "1.17" | "1.18" | "1.19";
              name: string;
              /** Please pin this a valid release version found in the repo. Suggestion: try the most recent stable version. */
              otomiVersion: string;
              provider: "aws" | "azure" | "google" | "oneprem";
              /** Dependent on provider. */
              region: string;
              /** AWS only. If provided will override autodiscovery from metadata. */
              vpcID?: string;
            };
            dns?: { [key: string]: any };
            core?: { [key: string]: any };
            isDirty?: boolean;
            namespaces?: string[];
            teams?: {
              id?: string;
              /** A team name */
              name: string;
              oidc?: {
                /** An OIDC group name/id granting access to this team */
                groupMapping?: string;
              };
              password?: string;
              alerts?: {
                email?: {
                  /** Email addresses (comma separated) for critical events. */
                  critical?: string;
                  /** One or more email addresses (comma separated) for non-critical events. */
                  nonCritical?: string;
                };
                msteams?: {
                  /** The high prio web hook */
                  highPrio?: string;
                  /** The low prio web hook */
                  lowPrio?: string;
                };
                receivers?: ("slack" | "msteams" | "email")[];
                slack?: {
                  /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                  channel?: string;
                  /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                  channelCrit?: string;
                  /** Slack web hook. If none is given the global one is used. */
                  url?: string;
                };
              };
            }[];
            user?: {
              /** A user name */
              name: string;
              email: string;
              /** If the user is admin */
              isAdmin: boolean;
              /** A list of teams the user belongs to */
              teams: string[];
              /** A list of roles that the user has */
              roles: string[];
            };
          };
        };
      };
      /** The requested session. */
      default: unknown;
    };
  };
  /** Get OpenAPIDoc document */
  apiDocs: {
    responses: {
      /** The requested apiDoc. */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** The requested apiDoc. */
      default: unknown;
    };
  };
  /** Get settings from the `settings.yaml` and `secret.settings.yaml` file. */
  getSettings: {
    responses: {
      /** The request is successful. */
      200: {
        content: {
          "application/json": {
            alerts?: {
              drone?: "slack" | "msteams";
              email?: {
                /** One or more email addresses (comma separated) for critical events. */
                critical?: string;
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
              };
              /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
              groupInterval?: string;
              msteams?: {
                /** The low prio web hook. */
                highPrio?: string;
                /** The high prio web hook. */
                lowPrio?: string;
              };
              /** Notification receivers. */
              receivers?: ("slack" | "msteams" | "email")[];
              /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
              repeatInterval?: string;
              slack?: {
                /** The Slack channel for non-critical notifications. */
                channel?: string;
                /** The Slack channel for critical notifications. */
                channelCrit?: string;
                /** A Slack webhook URL. */
                url?: string;
              };
            };
            /** Azure specific configuration. */
            azure?: {
              appgw?: {
                /** Is this appgw installed as AKS addon? */
                isManaged?: boolean;
              };
              /** An Azure disk type (SKU Type). */
              diskType:
                | "Standard_LRS"
                | "Standard_GRS"
                | "Standard_RAGRS"
                | "Standard_ZRS"
                | "Premium_LRS"
                | "Premium_ZRS"
                | "Standard_GZRS"
                | "Standard_RAGZRS";
              /** Azure Key Vault access credentials. Will use azure.tenantId if tenantId is not provided. */
              keyVault?: {
                /** An Azure tenant ID. */
                tenantId?: string;
                /** An Azure client ID. */
                clientId: string;
                /** An Azure client secret. */
                clientSecret: string;
              };
              monitor?: {
                /** An Azure AppInsights client secret (defaults to clientSecret). */
                appInsightsApiKey?: string;
                /** An Azure AppInsights client id (defaults to clientId). */
                appInsightsAppId?: string;
                /** An Azure client id. */
                clientId?: string;
                /** An Azure client secret. */
                clientSecret?: string;
                /** An Azure client secret (defaults to clientSecret). */
                logAnalyticsClientId?: string;
                /** An Azure client secret (defaults to clientSecret). */
                logAnalyticsClientSecret?: string;
                /** An Azure tenant id (defaults to tenantId). */
                logAnalyticsTenantId?: string;
                /** An Azure monitor log analytics workspace. */
                logAnalyticsWorkspace?: string;
              };
              /** An Azure resource group. */
              resourceGroup: string;
              /** An Azure subscription ID. */
              subscriptionId: string;
              /** An Azure tenant ID. */
              tenantId: string;
            };
            customer?: {
              name?: string;
            };
            /** Google specific configuration. */
            google?: {
              /** A service account key for managing a DNS zone. */
              cloudDnsKey: string;
              /** A service account key for managing a KMS vault. */
              kmsAccount?: string;
              /** A Google Cloud project ID for accessing DNS zone. */
              projectId: string;
            };
            dns?: (
              | {
                  aws: {
                    region: string;
                  };
                }
              | {
                  azure: {
                    /** Azure Cloud to use */
                    cloud?: string;
                    /** Azure resource group to use */
                    resourceGroup: string;
                    hostedZoneName?: string;
                    /** Azure tenant ID to use (will default to global value) */
                    tenantId: string;
                    /** Azure subscription ID to use (will default to global value) */
                    subscriptionId: string;
                    /** Azure Application Client ID to use */
                    aadClientId: string;
                    /** Azure Application Client Secret to use */
                    aadClientSecret: string;
                    /** If you use Azure MSI, this should be set to true */
                    useManagedIdentityExtension?: boolean;
                  };
                }
              | {
                  google: {
                    /** A service account key for managing a DNS zone. */
                    serviceAccountKey: string;
                    project: string;
                  };
                }
            ) & {
              /** Extra dns zones that the cluster can administer (see dns). Team services can use this to publish their URLs on. */
              dnsZones?: string[];
              /** A fqdn for the cluster */
              domain: string;
            };
            home?: {
              drone?: "slack" | "msteams";
              email?: {
                /** One or more email addresses (comma separated) for critical events. */
                critical?: string;
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
              };
              /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
              groupInterval?: string;
              msteams?: {
                /** The low prio web hook. */
                highPrio?: string;
                /** The high prio web hook. */
                lowPrio?: string;
              };
              /** Notification receivers. */
              receivers?: ("slack" | "msteams" | "email")[];
              /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
              repeatInterval?: string;
              slack?: {
                /** The Slack channel for non-critical notifications. */
                channel?: string;
                /** The Slack channel for critical notifications. */
                channelCrit?: string;
                /** A Slack webhook URL. */
                url?: string;
              };
            };
            /** Use Cloud KMS to encrypt and decrypt the master key */
            kms?:
              | {
                  gcpckms: {
                    project: string;
                    region: string;
                    key_ring: string;
                    kmsAccount: string;
                  };
                }
              | {
                  awskms: {
                    region: string;
                    access_key: string;
                    secret_key: string;
                    endpoint: string;
                  };
                }
              | {
                  azurekeyvault: {
                    vault_name: string;
                    tenant_id: string;
                    client_id: string;
                    client_secret: string;
                  };
                };
            /** Holds many parts used in different locations. Please see keycloak, istio and oauth-proxy all consuming parts. */
            oidc?: {
              adminGroupID?: string;
              apiUrl?: string;
              authUrl?: string;
              clientID?: string;
              clientSecret?: string;
              issuer?: string;
              scope?: string;
              teamAdminGroupID?: string;
              tenantID?: string;
              tokenUrl?: string;
              /** Claim name used by Keycloak to identify incoming users from identity provider */
              usernameClaimMapper?: string;
              /** Select OIDC claim to be used as a unique user identifier */
              subClaimMapper?: string;
            };
            otomi?: {
              /** Set this to true when an external LB exists or needs to be started (AWS ALB, Azure AppGW, Google Apigee). This will then be configured through ingress controllers. Expects existing LBs to terminate https. Currently this is only working correctly for Azure, and not for AWS and Google. AWS is close to completion. */
              hasCloudLB?: boolean;
              /** Whether this cluster is home monitored (like when under a Premium SLA). Sends criticals home. */
              isHomeMonitored?: boolean;
              /** Whether masters are managed and not under control. Set this to false when onprem. */
              isManaged?: boolean;
              /** Whether to separate team metrics and logs. Disabling this lets everybody be admin and see everything. */
              isMultitenant?: boolean;
              /** The otomi-core edition. Either community edition (ce) or enterprise edition (ee). */
              mode?: "ce" | "ee";
              /** The pullsecret to deploy the Otomi API and Console. Requires an Otomi license. */
              pullSecret?: string;
              /** The prefix to use in URLs for team domains. */
              teamPrefix?: string;
              /** Manage addon configuration */
              addons?: {
                conftest?: {
                  /** Use this flag to enable conftest for policy validation */
                  enabled?: boolean;
                };
              };
            };
            smtp?: {
              auth_identity?: string;
              auth_password?: string;
              auth_secret?: string;
              auth_username?: string;
              /** The "from" address. Defaults to alerts@$clusterDomain. */
              from?: string;
              hello?: string;
              /** The smtp host:port combination. */
              smarthost: string;
            };
          };
        };
      };
    };
  };
  /** Edits the settings from the `settings.yaml` file */
  editSettings: {
    responses: {
      /** Successfully edited `settings.yaml` */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Settings object that contains updated values */
    requestBody: {
      content: {
        "application/json": {
          alerts?: {
            drone?: "slack" | "msteams";
            email?: {
              /** One or more email addresses (comma separated) for critical events. */
              critical?: string;
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
            };
            /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
            groupInterval?: string;
            msteams?: {
              /** The low prio web hook. */
              highPrio?: string;
              /** The high prio web hook. */
              lowPrio?: string;
            };
            /** Notification receivers. */
            receivers?: ("slack" | "msteams" | "email")[];
            /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
            repeatInterval?: string;
            slack?: {
              /** The Slack channel for non-critical notifications. */
              channel?: string;
              /** The Slack channel for critical notifications. */
              channelCrit?: string;
              /** A Slack webhook URL. */
              url?: string;
            };
          };
          /** Azure specific configuration. */
          azure?: {
            appgw?: {
              /** Is this appgw installed as AKS addon? */
              isManaged?: boolean;
            };
            /** An Azure disk type (SKU Type). */
            diskType:
              | "Standard_LRS"
              | "Standard_GRS"
              | "Standard_RAGRS"
              | "Standard_ZRS"
              | "Premium_LRS"
              | "Premium_ZRS"
              | "Standard_GZRS"
              | "Standard_RAGZRS";
            /** Azure Key Vault access credentials. Will use azure.tenantId if tenantId is not provided. */
            keyVault?: {
              /** An Azure tenant ID. */
              tenantId?: string;
              /** An Azure client ID. */
              clientId: string;
              /** An Azure client secret. */
              clientSecret: string;
            };
            monitor?: {
              /** An Azure AppInsights client secret (defaults to clientSecret). */
              appInsightsApiKey?: string;
              /** An Azure AppInsights client id (defaults to clientId). */
              appInsightsAppId?: string;
              /** An Azure client id. */
              clientId?: string;
              /** An Azure client secret. */
              clientSecret?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientId?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientSecret?: string;
              /** An Azure tenant id (defaults to tenantId). */
              logAnalyticsTenantId?: string;
              /** An Azure monitor log analytics workspace. */
              logAnalyticsWorkspace?: string;
            };
            /** An Azure resource group. */
            resourceGroup: string;
            /** An Azure subscription ID. */
            subscriptionId: string;
            /** An Azure tenant ID. */
            tenantId: string;
          };
          customer?: {
            name?: string;
          };
          /** Google specific configuration. */
          google?: {
            /** A service account key for managing a DNS zone. */
            cloudDnsKey: string;
            /** A service account key for managing a KMS vault. */
            kmsAccount?: string;
            /** A Google Cloud project ID for accessing DNS zone. */
            projectId: string;
          };
          dns?: (
            | {
                aws: {
                  region: string;
                };
              }
            | {
                azure: {
                  /** Azure Cloud to use */
                  cloud?: string;
                  /** Azure resource group to use */
                  resourceGroup: string;
                  hostedZoneName?: string;
                  /** Azure tenant ID to use (will default to global value) */
                  tenantId: string;
                  /** Azure subscription ID to use (will default to global value) */
                  subscriptionId: string;
                  /** Azure Application Client ID to use */
                  aadClientId: string;
                  /** Azure Application Client Secret to use */
                  aadClientSecret: string;
                  /** If you use Azure MSI, this should be set to true */
                  useManagedIdentityExtension?: boolean;
                };
              }
            | {
                google: {
                  /** A service account key for managing a DNS zone. */
                  serviceAccountKey: string;
                  project: string;
                };
              }
          ) & {
            /** Extra dns zones that the cluster can administer (see dns). Team services can use this to publish their URLs on. */
            dnsZones?: string[];
            /** A fqdn for the cluster */
            domain: string;
          };
          home?: {
            drone?: "slack" | "msteams";
            email?: {
              /** One or more email addresses (comma separated) for critical events. */
              critical?: string;
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
            };
            /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
            groupInterval?: string;
            msteams?: {
              /** The low prio web hook. */
              highPrio?: string;
              /** The high prio web hook. */
              lowPrio?: string;
            };
            /** Notification receivers. */
            receivers?: ("slack" | "msteams" | "email")[];
            /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
            repeatInterval?: string;
            slack?: {
              /** The Slack channel for non-critical notifications. */
              channel?: string;
              /** The Slack channel for critical notifications. */
              channelCrit?: string;
              /** A Slack webhook URL. */
              url?: string;
            };
          };
          /** Use Cloud KMS to encrypt and decrypt the master key */
          kms?:
            | {
                gcpckms: {
                  project: string;
                  region: string;
                  key_ring: string;
                  kmsAccount: string;
                };
              }
            | {
                awskms: {
                  region: string;
                  access_key: string;
                  secret_key: string;
                  endpoint: string;
                };
              }
            | {
                azurekeyvault: {
                  vault_name: string;
                  tenant_id: string;
                  client_id: string;
                  client_secret: string;
                };
              };
          /** Holds many parts used in different locations. Please see keycloak, istio and oauth-proxy all consuming parts. */
          oidc?: {
            adminGroupID?: string;
            apiUrl?: string;
            authUrl?: string;
            clientID?: string;
            clientSecret?: string;
            issuer?: string;
            scope?: string;
            teamAdminGroupID?: string;
            tenantID?: string;
            tokenUrl?: string;
            /** Claim name used by Keycloak to identify incoming users from identity provider */
            usernameClaimMapper?: string;
            /** Select OIDC claim to be used as a unique user identifier */
            subClaimMapper?: string;
          };
          otomi?: {
            /** Set this to true when an external LB exists or needs to be started (AWS ALB, Azure AppGW, Google Apigee). This will then be configured through ingress controllers. Expects existing LBs to terminate https. Currently this is only working correctly for Azure, and not for AWS and Google. AWS is close to completion. */
            hasCloudLB?: boolean;
            /** Whether this cluster is home monitored (like when under a Premium SLA). Sends criticals home. */
            isHomeMonitored?: boolean;
            /** Whether masters are managed and not under control. Set this to false when onprem. */
            isManaged?: boolean;
            /** Whether to separate team metrics and logs. Disabling this lets everybody be admin and see everything. */
            isMultitenant?: boolean;
            /** The otomi-core edition. Either community edition (ce) or enterprise edition (ee). */
            mode?: "ce" | "ee";
            /** The pullsecret to deploy the Otomi API and Console. Requires an Otomi license. */
            pullSecret?: string;
            /** The prefix to use in URLs for team domains. */
            teamPrefix?: string;
            /** Manage addon configuration */
            addons?: {
              conftest?: {
                /** Use this flag to enable conftest for policy validation */
                enabled?: boolean;
              };
            };
          };
          smtp?: {
            auth_identity?: string;
            auth_password?: string;
            auth_secret?: string;
            auth_username?: string;
            /** The "from" address. Defaults to alerts@$clusterDomain. */
            from?: string;
            hello?: string;
            /** The smtp host:port combination. */
            smarthost: string;
          };
        };
      };
    };
  };
}
