/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/clusters": {
    /** Get available clusters */
    get: operations["getClusters"];
  };
  "/secrets": {
    /** Get all secrets */
    get: operations["getAllSecrets"];
  };
  "/services": {
    /** Get services from a given team */
    get: operations["getAllServices"];
  };
  "/teams": {
    /** Get teams collection */
    get: operations["getTeams"];
    /** Create a team */
    post: operations["createTeam"];
  };
  "/teams/{teamId}": {
    /** Get a specific team */
    get: operations["getTeam"];
    /** Edit a team */
    put: operations["editTeam"];
    /** Delete team */
    delete: operations["deleteTeam"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/teams/{teamId}/services": {
    /** Get services from a given team */
    get: operations["getTeamServices"];
    /** Create a service */
    post: operations["createService"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/teams/{teamId}/services/{serviceId}": {
    /** Get a service from a given team */
    get: operations["getService"];
    /** Edit a service from a given team */
    put: operations["editService"];
    /** Delete a service from a given team */
    delete: operations["deleteService"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
  };
  "/teams/{teamId}/secrets": {
    /** Get secrets from a given team */
    get: operations["getSecrets"];
    /** Create a team secret */
    post: operations["createSecret"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/teams/{teamId}/secrets/{secretId}": {
    /** Get a secret from a given team */
    get: operations["getSecret"];
    /** Edit a secret from a given team */
    put: operations["editSecret"];
    /** Delete a secret from a given team */
    delete: operations["deleteSecret"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
  };
  "/deploy": {
    /** Trigger a deployment (only for admin) */
    get: operations["deploy"];
  };
  "/kubecfg/{teamId}": {
    /** Download a kubecfg for a team */
    get: operations["downloadKubecfg"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/session": {
    /** Get the session for the current user */
    get: operations["getSession"];
  };
  "/apiDocs": {
    /** Get OpenAPIDoc document */
    get: {
      responses: {
        /** The requested apiDoc. */
        200: {
          content: {
            "application/json": { [key: string]: any };
          };
        };
        /** The requested apiDoc. */
        default: unknown;
      };
    };
  };
  "/settings": {
    /** Get settings from the `settings.yaml` and `secret.settings.yaml` file. */
    get: {
      responses: {
        /** The request is successful. */
        200: {
          content: {
            "application/json": {
              /** Placeholder (copy schema from otomi-core) */
              alerts?: { [key: string]: any };
            };
          };
        };
      };
    };
    /** Edits the settings from the `settings.yaml` file */
    put: operations["editSettings"];
  };
}

export interface components {
  schemas: {
    Cloud: {
      /** A cluster name */
      name?: string;
      clusters?: {
        enabled?: boolean;
        /** A cluster name */
        name?: string;
        /** A cloud provider name */
        cloud?: string;
        /** A default cluster DNS zone */
        domain?: string;
        /** A list of DNS zones that are available to the cluster */
        dnsZones?: string[];
        /** A flag that indicates capability for deploying serverless services by using Knative */
        hasKnative?: boolean;
        /** A version of kubernetes that is installed on the cluster */
        k8sVersion?: string;
        /** A version of kubernetes that is installed on the cluster */
        otomiVersion?: string;
        /** A physical location of the cluster */
        region?: string;
        /** An unique cluster identifier */
        clusterId?: string;
      }[];
      /** A fqdn for the cloud */
      domain?: string;
    };
    Cluster: {
      enabled?: boolean;
      /** A cluster name */
      name?: string;
      /** A cloud provider name */
      cloud?: string;
      /** A default cluster DNS zone */
      domain?: string;
      /** A list of DNS zones that are available to the cluster */
      dnsZones?: string[];
      /** A flag that indicates capability for deploying serverless services by using Knative */
      hasKnative?: boolean;
      /** A version of kubernetes that is installed on the cluster */
      k8sVersion?: string;
      /** A version of kubernetes that is installed on the cluster */
      otomiVersion?: string;
      /** A physical location of the cluster */
      region?: string;
      /** An unique cluster identifier */
      clusterId?: string;
    };
    Clusters: {
      enabled?: boolean;
      /** A cluster name */
      name?: string;
      /** A cloud provider name */
      cloud?: string;
      /** A default cluster DNS zone */
      domain?: string;
      /** A list of DNS zones that are available to the cluster */
      dnsZones?: string[];
      /** A flag that indicates capability for deploying serverless services by using Knative */
      hasKnative?: boolean;
      /** A version of kubernetes that is installed on the cluster */
      k8sVersion?: string;
      /** A version of kubernetes that is installed on the cluster */
      otomiVersion?: string;
      /** A physical location of the cluster */
      region?: string;
      /** An unique cluster identifier */
      clusterId?: string;
    }[];
    Deployment: {
      id?: number;
      /** Deployment status */
      status?: "in-progress" | "completed" | "failed";
    };
    Kubecfg: { [key: string]: any };
    OpenApiValidationError: {
      status?: number;
      errors?: {
        path?: string;
        errorCode?: string;
        message?: string;
        location?: "body" | "path";
      }[];
    };
    OtomiStackError: {
      message?: string;
    };
    Secret: (
      | {
          type: "generic";
          entries: string[];
        }
      | {
          type: "docker-registry";
          dockerconfig?: ".dockerconfig.json";
        }
      | {
          type: "tls";
          /** A Vault property name that contains PEM public key certificate */
          crt: string;
          /** A Vault property name that contains PEM private key certificate */
          key: string;
          /** A Vault property name that contains CA certificate content */
          ca?: string;
        }
    ) & {
      id?: string;
      /** A secret name */
      name: string;
      /** A kubernetes cluster for the secret */
      clusterId: string;
    };
    Secrets: {
      secrets?: ((
        | {
            type: "generic";
            entries: string[];
          }
        | {
            type: "docker-registry";
            dockerconfig?: ".dockerconfig.json";
          }
        | {
            type: "tls";
            /** A Vault property name that contains PEM public key certificate */
            crt: string;
            /** A Vault property name that contains PEM private key certificate */
            key: string;
            /** A Vault property name that contains CA certificate content */
            ca?: string;
          }
      ) & {
        id?: string;
        /** A secret name */
        name: string;
        /** A kubernetes cluster for the secret */
        clusterId: string;
      })[];
    };
    Service: {
      enabled?: boolean;
      id?: string;
      /** A service name */
      name: string;
      /** A kubernetes cluster for the service */
      clusterId: string;
      port?: number;
      ksvc?:
        | ({
            serviceType?: "ksvc";
            /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
            scaleToZero?: boolean;
            image?: {
              /** A container image repository */
              repository?: string;
              tag?: string;
            } | null;
            secrets?:
              | {
                  name: string;
                  entries?: string[];
                }[]
              | null;
            env?:
              | {
                  name: string;
                  value: string;
                }[]
              | null;
            resources?: {
              requests?: {
                /** The guaranteed amount of CPU */
                cpu: string;
                /** The guaranteed amount of RAM */
                memory: string;
              };
              limits?: {
                /** The maximum amount of CPU */
                cpu: string;
                /** The maximum amount of RAM */
                memory: string;
              };
            } | null;
            /** Kubernetes annotations with arbitrary metadata */
            annotations?: {
              name?: string;
              value?: string;
            }[];
            /** Deploys new images based on a tagging strategy */
            autoCD?:
              | ({ [key: string]: any } | null)
              | ({
                  tagMatcher?: "semver";
                  /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                  semver: string;
                } | null)
              | {
                  tagMatcher?: "glob";
                  /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                  glob: string;
                };
          } | null)
        | {
            serviceType: "ksvcPredeployed";
          }
        | {
            serviceType: "svcPredeployed";
          };
      ingress?:
        | ({ [key: string]: any } | null)
        | ({
            /** Use the team domain so that the URL reveals the owner. */
            useDefaultSubdomain?: boolean;
            /** A host that is used to set DNS 'A' records */
            subdomain?: string | null;
            /** A managed DNS zone */
            domain?: string;
            /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
            path?: string;
            /** Forward the URL path into the service (don't rewrite to /) */
            forwardPath?: boolean;
            hasSingleSignOn?: boolean;
            /** If true a certificate should exist already */
            hasCert?: boolean;
            certArn?: string;
            certSelect?: boolean;
            certName?: string;
          } | null);
      teamId: string;
    };
    Services: {
      enabled?: boolean;
      id?: string;
      /** A service name */
      name: string;
      /** A kubernetes cluster for the service */
      clusterId: string;
      port?: number;
      ksvc?:
        | ({
            serviceType?: "ksvc";
            /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
            scaleToZero?: boolean;
            image?: {
              /** A container image repository */
              repository?: string;
              tag?: string;
            } | null;
            secrets?:
              | {
                  name: string;
                  entries?: string[];
                }[]
              | null;
            env?:
              | {
                  name: string;
                  value: string;
                }[]
              | null;
            resources?: {
              requests?: {
                /** The guaranteed amount of CPU */
                cpu: string;
                /** The guaranteed amount of RAM */
                memory: string;
              };
              limits?: {
                /** The maximum amount of CPU */
                cpu: string;
                /** The maximum amount of RAM */
                memory: string;
              };
            } | null;
            /** Kubernetes annotations with arbitrary metadata */
            annotations?: {
              name?: string;
              value?: string;
            }[];
            /** Deploys new images based on a tagging strategy */
            autoCD?:
              | ({ [key: string]: any } | null)
              | ({
                  tagMatcher?: "semver";
                  /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                  semver: string;
                } | null)
              | {
                  tagMatcher?: "glob";
                  /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                  glob: string;
                };
          } | null)
        | {
            serviceType: "ksvcPredeployed";
          }
        | {
            serviceType: "svcPredeployed";
          };
      ingress?:
        | ({ [key: string]: any } | null)
        | ({
            /** Use the team domain so that the URL reveals the owner. */
            useDefaultSubdomain?: boolean;
            /** A host that is used to set DNS 'A' records */
            subdomain?: string | null;
            /** A managed DNS zone */
            domain?: string;
            /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
            path?: string;
            /** Forward the URL path into the service (don't rewrite to /) */
            forwardPath?: boolean;
            hasSingleSignOn?: boolean;
            /** If true a certificate should exist already */
            hasCert?: boolean;
            certArn?: string;
            certSelect?: boolean;
            certName?: string;
          } | null);
      teamId: string;
    }[];
    Session: {
      clusters?: string[];
      core?: { [key: string]: any };
      currentClusterId?: string;
      isDirty?: boolean;
      namespaces?: string[];
      teams?: {
        id?: string;
        /** A team name */
        name: string;
        clusters: string[];
        oidc?: {
          /** An OIDC group name/id granting access to this team */
          groupMapping?: string;
        };
        password: string;
        alerts?: {
          receivers?: ("slack" | "msteams" | "email")[];
          slack?: {
            /** Slack web hook. If none is given the global one is used. */
            url?: string;
            /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
            channel?: string;
            /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
            channelCrit?: string;
          };
          msteams?: {
            /** The low prio web hook */
            lowPrio?: string;
            /** The high prio web hook */
            highPrio?: string;
          };
          email?: {
            /** One or more email addresses (comma separated) for non-critical events. */
            nonCritical?: string;
            /** Email addresses (comma separated) for critical events. */
            critical?: string;
          };
        };
        /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
        azureMonitor?: Partial<{ [key: string]: any } | null> &
          Partial<{
            /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
            clientId: string;
            /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
            clientSecret: string;
            /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
            logAnalyticsClientId?: string;
            /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
            logAnalyticsClientSecret?: string;
            /** An app id for use with an Application Insights resource. Defaults to clientId value. */
            appInsightsAppId?: string;
            /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
            appInsightsApiKey?: string;
          } | null>;
      }[];
      user?: {
        /** A user name */
        name?: string;
        /** An email address */
        email?: string;
        /** If the user is admin */
        isAdmin?: boolean;
        /** A list of teams the user belongs to */
        teams?: string[];
        /** A list of roles that the user has */
        roles?: string[];
      };
    };
    Settings: {
      /** Placeholder (copy schema from otomi-core) */
      alerts?: { [key: string]: any };
    };
    Team: {
      id?: string;
      /** A team name */
      name: string;
      clusters: string[];
      oidc?: {
        /** An OIDC group name/id granting access to this team */
        groupMapping?: string;
      };
      password: string;
      alerts?: {
        receivers?: ("slack" | "msteams" | "email")[];
        slack?: {
          /** Slack web hook. If none is given the global one is used. */
          url?: string;
          /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
          channel?: string;
          /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
          channelCrit?: string;
        };
        msteams?: {
          /** The low prio web hook */
          lowPrio?: string;
          /** The high prio web hook */
          highPrio?: string;
        };
        email?: {
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
          /** Email addresses (comma separated) for critical events. */
          critical?: string;
        };
      };
      /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
      azureMonitor?: Partial<{ [key: string]: any } | null> &
        Partial<{
          /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
          clientId: string;
          /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
          clientSecret: string;
          /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
          logAnalyticsClientId?: string;
          /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
          logAnalyticsClientSecret?: string;
          /** An app id for use with an Application Insights resource. Defaults to clientId value. */
          appInsightsAppId?: string;
          /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
          appInsightsApiKey?: string;
        } | null>;
    };
    Teams: {
      teams?: {
        id?: string;
        /** A team name */
        name: string;
        clusters: string[];
        oidc?: {
          /** An OIDC group name/id granting access to this team */
          groupMapping?: string;
        };
        password: string;
        alerts?: {
          receivers?: ("slack" | "msteams" | "email")[];
          slack?: {
            /** Slack web hook. If none is given the global one is used. */
            url?: string;
            /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
            channel?: string;
            /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
            channelCrit?: string;
          };
          msteams?: {
            /** The low prio web hook */
            lowPrio?: string;
            /** The high prio web hook */
            highPrio?: string;
          };
          email?: {
            /** One or more email addresses (comma separated) for non-critical events. */
            nonCritical?: string;
            /** Email addresses (comma separated) for critical events. */
            critical?: string;
          };
        };
        /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
        azureMonitor?: Partial<{ [key: string]: any } | null> &
          Partial<{
            /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
            clientId: string;
            /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
            clientSecret: string;
            /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
            logAnalyticsClientId?: string;
            /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
            logAnalyticsClientSecret?: string;
            /** An app id for use with an Application Insights resource. Defaults to clientId value. */
            appInsightsAppId?: string;
            /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
            appInsightsApiKey?: string;
          } | null>;
      }[];
    };
    User: {
      /** A user name */
      name: string;
      /** An email address */
      email: string;
      /** If the user is admin */
      isAdmin: boolean;
      /** A list of teams the user belongs to */
      teams: string[];
      /** A list of roles that the user has */
      roles: string[];
    };
    cluster_Cluster: {
      enabled?: boolean;
      /** A cluster name */
      name?: string;
      /** A cloud provider name */
      cloud?: string;
      /** A default cluster DNS zone */
      domain?: string;
      /** A list of DNS zones that are available to the cluster */
      dnsZones?: string[];
      /** A flag that indicates capability for deploying serverless services by using Knative */
      hasKnative?: boolean;
      /** A version of kubernetes that is installed on the cluster */
      k8sVersion?: string;
      /** A version of kubernetes that is installed on the cluster */
      otomiVersion?: string;
      /** A physical location of the cluster */
      region?: string;
      /** An unique cluster identifier */
      clusterId?: string;
    };
    clusters_Clusters: {
      enabled?: boolean;
      /** A cluster name */
      name?: string;
      /** A cloud provider name */
      cloud?: string;
      /** A default cluster DNS zone */
      domain?: string;
      /** A list of DNS zones that are available to the cluster */
      dnsZones?: string[];
      /** A flag that indicates capability for deploying serverless services by using Knative */
      hasKnative?: boolean;
      /** A version of kubernetes that is installed on the cluster */
      k8sVersion?: string;
      /** A version of kubernetes that is installed on the cluster */
      otomiVersion?: string;
      /** A physical location of the cluster */
      region?: string;
      /** An unique cluster identifier */
      clusterId?: string;
    }[];
    secret_Secret: (
      | {
          type: "generic";
          entries: string[];
        }
      | {
          type: "docker-registry";
          dockerconfig?: ".dockerconfig.json";
        }
      | {
          type: "tls";
          /** A Vault property name that contains PEM public key certificate */
          crt: string;
          /** A Vault property name that contains PEM private key certificate */
          key: string;
          /** A Vault property name that contains CA certificate content */
          ca?: string;
        }
    ) & {
      id?: string;
      /** A secret name */
      name: string;
      /** A kubernetes cluster for the secret */
      clusterId: string;
    };
    secrets_Secrets: {
      secrets?: ((
        | {
            type: "generic";
            entries: string[];
          }
        | {
            type: "docker-registry";
            dockerconfig?: ".dockerconfig.json";
          }
        | {
            type: "tls";
            /** A Vault property name that contains PEM public key certificate */
            crt: string;
            /** A Vault property name that contains PEM private key certificate */
            key: string;
            /** A Vault property name that contains CA certificate content */
            ca?: string;
          }
      ) & {
        id?: string;
        /** A secret name */
        name: string;
        /** A kubernetes cluster for the secret */
        clusterId: string;
      })[];
    };
    error_OpenApiValidationError: {
      status?: number;
      errors?: {
        path?: string;
        errorCode?: string;
        message?: string;
        location?: "body" | "path";
      }[];
    };
    service_Service: {
      enabled?: boolean;
      id?: string;
      /** A service name */
      name: string;
      /** A kubernetes cluster for the service */
      clusterId: string;
      port?: number;
      ksvc?:
        | ({
            serviceType?: "ksvc";
            /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
            scaleToZero?: boolean;
            image?: {
              /** A container image repository */
              repository?: string;
              tag?: string;
            } | null;
            secrets?:
              | {
                  name: string;
                  entries?: string[];
                }[]
              | null;
            env?:
              | {
                  name: string;
                  value: string;
                }[]
              | null;
            resources?: {
              requests?: {
                /** The guaranteed amount of CPU */
                cpu: string;
                /** The guaranteed amount of RAM */
                memory: string;
              };
              limits?: {
                /** The maximum amount of CPU */
                cpu: string;
                /** The maximum amount of RAM */
                memory: string;
              };
            } | null;
            /** Kubernetes annotations with arbitrary metadata */
            annotations?: {
              name?: string;
              value?: string;
            }[];
            /** Deploys new images based on a tagging strategy */
            autoCD?:
              | ({ [key: string]: any } | null)
              | ({
                  tagMatcher?: "semver";
                  /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                  semver: string;
                } | null)
              | {
                  tagMatcher?: "glob";
                  /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                  glob: string;
                };
          } | null)
        | {
            serviceType: "ksvcPredeployed";
          }
        | {
            serviceType: "svcPredeployed";
          };
      ingress?:
        | ({ [key: string]: any } | null)
        | ({
            /** Use the team domain so that the URL reveals the owner. */
            useDefaultSubdomain?: boolean;
            /** A host that is used to set DNS 'A' records */
            subdomain?: string | null;
            /** A managed DNS zone */
            domain?: string;
            /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
            path?: string;
            /** Forward the URL path into the service (don't rewrite to /) */
            forwardPath?: boolean;
            hasSingleSignOn?: boolean;
            /** If true a certificate should exist already */
            hasCert?: boolean;
            certArn?: string;
            certSelect?: boolean;
            certName?: string;
          } | null);
      teamId: string;
    };
    services_Services: {
      enabled?: boolean;
      id?: string;
      /** A service name */
      name: string;
      /** A kubernetes cluster for the service */
      clusterId: string;
      port?: number;
      ksvc?:
        | ({
            serviceType?: "ksvc";
            /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
            scaleToZero?: boolean;
            image?: {
              /** A container image repository */
              repository?: string;
              tag?: string;
            } | null;
            secrets?:
              | {
                  name: string;
                  entries?: string[];
                }[]
              | null;
            env?:
              | {
                  name: string;
                  value: string;
                }[]
              | null;
            resources?: {
              requests?: {
                /** The guaranteed amount of CPU */
                cpu: string;
                /** The guaranteed amount of RAM */
                memory: string;
              };
              limits?: {
                /** The maximum amount of CPU */
                cpu: string;
                /** The maximum amount of RAM */
                memory: string;
              };
            } | null;
            /** Kubernetes annotations with arbitrary metadata */
            annotations?: {
              name?: string;
              value?: string;
            }[];
            /** Deploys new images based on a tagging strategy */
            autoCD?:
              | ({ [key: string]: any } | null)
              | ({
                  tagMatcher?: "semver";
                  /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                  semver: string;
                } | null)
              | {
                  tagMatcher?: "glob";
                  /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                  glob: string;
                };
          } | null)
        | {
            serviceType: "ksvcPredeployed";
          }
        | {
            serviceType: "svcPredeployed";
          };
      ingress?:
        | ({ [key: string]: any } | null)
        | ({
            /** Use the team domain so that the URL reveals the owner. */
            useDefaultSubdomain?: boolean;
            /** A host that is used to set DNS 'A' records */
            subdomain?: string | null;
            /** A managed DNS zone */
            domain?: string;
            /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
            path?: string;
            /** Forward the URL path into the service (don't rewrite to /) */
            forwardPath?: boolean;
            hasSingleSignOn?: boolean;
            /** If true a certificate should exist already */
            hasCert?: boolean;
            certArn?: string;
            certSelect?: boolean;
            certName?: string;
          } | null);
      teamId: string;
    }[];
    team_Team: {
      id?: string;
      /** A team name */
      name: string;
      clusters: string[];
      oidc?: {
        /** An OIDC group name/id granting access to this team */
        groupMapping?: string;
      };
      password: string;
      alerts?: {
        receivers?: ("slack" | "msteams" | "email")[];
        slack?: {
          /** Slack web hook. If none is given the global one is used. */
          url?: string;
          /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
          channel?: string;
          /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
          channelCrit?: string;
        };
        msteams?: {
          /** The low prio web hook */
          lowPrio?: string;
          /** The high prio web hook */
          highPrio?: string;
        };
        email?: {
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
          /** Email addresses (comma separated) for critical events. */
          critical?: string;
        };
      };
      /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
      azureMonitor?: Partial<{ [key: string]: any } | null> &
        Partial<{
          /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
          clientId: string;
          /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
          clientSecret: string;
          /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
          logAnalyticsClientId?: string;
          /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
          logAnalyticsClientSecret?: string;
          /** An app id for use with an Application Insights resource. Defaults to clientId value. */
          appInsightsAppId?: string;
          /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
          appInsightsApiKey?: string;
        } | null>;
    };
    teams_Teams: {
      teams?: {
        id?: string;
        /** A team name */
        name: string;
        clusters: string[];
        oidc?: {
          /** An OIDC group name/id granting access to this team */
          groupMapping?: string;
        };
        password: string;
        alerts?: {
          receivers?: ("slack" | "msteams" | "email")[];
          slack?: {
            /** Slack web hook. If none is given the global one is used. */
            url?: string;
            /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
            channel?: string;
            /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
            channelCrit?: string;
          };
          msteams?: {
            /** The low prio web hook */
            lowPrio?: string;
            /** The high prio web hook */
            highPrio?: string;
          };
          email?: {
            /** One or more email addresses (comma separated) for non-critical events. */
            nonCritical?: string;
            /** Email addresses (comma separated) for critical events. */
            critical?: string;
          };
        };
        /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
        azureMonitor?: Partial<{ [key: string]: any } | null> &
          Partial<{
            /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
            clientId: string;
            /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
            clientSecret: string;
            /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
            logAnalyticsClientId?: string;
            /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
            logAnalyticsClientSecret?: string;
            /** An app id for use with an Application Insights resource. Defaults to clientId value. */
            appInsightsAppId?: string;
            /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
            appInsightsApiKey?: string;
          } | null>;
      }[];
    };
    error_OtomiStackError: {
      message?: string;
    };
    session_Session: {
      clusters?: string[];
      core?: { [key: string]: any };
      currentClusterId?: string;
      isDirty?: boolean;
      namespaces?: string[];
      teams?: {
        id?: string;
        /** A team name */
        name: string;
        clusters: string[];
        oidc?: {
          /** An OIDC group name/id granting access to this team */
          groupMapping?: string;
        };
        password: string;
        alerts?: {
          receivers?: ("slack" | "msteams" | "email")[];
          slack?: {
            /** Slack web hook. If none is given the global one is used. */
            url?: string;
            /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
            channel?: string;
            /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
            channelCrit?: string;
          };
          msteams?: {
            /** The low prio web hook */
            lowPrio?: string;
            /** The high prio web hook */
            highPrio?: string;
          };
          email?: {
            /** One or more email addresses (comma separated) for non-critical events. */
            nonCritical?: string;
            /** Email addresses (comma separated) for critical events. */
            critical?: string;
          };
        };
        /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
        azureMonitor?: Partial<{ [key: string]: any } | null> &
          Partial<{
            /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
            clientId: string;
            /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
            clientSecret: string;
            /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
            logAnalyticsClientId?: string;
            /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
            logAnalyticsClientSecret?: string;
            /** An app id for use with an Application Insights resource. Defaults to clientId value. */
            appInsightsAppId?: string;
            /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
            appInsightsApiKey?: string;
          } | null>;
      }[];
      user?: {
        /** A user name */
        name?: string;
        /** An email address */
        email?: string;
        /** If the user is admin */
        isAdmin?: boolean;
        /** A list of teams the user belongs to */
        teams?: string[];
        /** A list of roles that the user has */
        roles?: string[];
      };
    };
    settings_Settings: {
      /** Placeholder (copy schema from otomi-core) */
      alerts?: { [key: string]: any };
    };
    cloud_Cloud: {
      /** A cluster name */
      name?: string;
      clusters?: {
        enabled?: boolean;
        /** A cluster name */
        name?: string;
        /** A cloud provider name */
        cloud?: string;
        /** A default cluster DNS zone */
        domain?: string;
        /** A list of DNS zones that are available to the cluster */
        dnsZones?: string[];
        /** A flag that indicates capability for deploying serverless services by using Knative */
        hasKnative?: boolean;
        /** A version of kubernetes that is installed on the cluster */
        k8sVersion?: string;
        /** A version of kubernetes that is installed on the cluster */
        otomiVersion?: string;
        /** A physical location of the cluster */
        region?: string;
        /** An unique cluster identifier */
        clusterId?: string;
      }[];
      /** A fqdn for the cloud */
      domain?: string;
    };
    deployment_Deployment: {
      id?: number;
      /** Deployment status */
      status?: "in-progress" | "completed" | "failed";
    };
    kubecfg_Kubecfg: { [key: string]: any };
    user_User: {
      /** A user name */
      name: string;
      /** An email address */
      email: string;
      /** If the user is admin */
      isAdmin: boolean;
      /** A list of teams the user belongs to */
      teams: string[];
      /** A list of roles that the user has */
      roles: string[];
    };
  };
  parameters: {
    /** ID of team to return */
    teamParams: string;
    /** ID of the service */
    serviceParams: string;
    /** ID of the secret */
    secretParams: string;
  };
}

export interface operations {
  /** Get available clusters */
  getClusters: {
    responses: {
      /** Successfully obtained cluster collection */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            /** A cluster name */
            name?: string;
            /** A cloud provider name */
            cloud?: string;
            /** A default cluster DNS zone */
            domain?: string;
            /** A list of DNS zones that are available to the cluster */
            dnsZones?: string[];
            /** A flag that indicates capability for deploying serverless services by using Knative */
            hasKnative?: boolean;
            /** A version of kubernetes that is installed on the cluster */
            k8sVersion?: string;
            /** A version of kubernetes that is installed on the cluster */
            otomiVersion?: string;
            /** A physical location of the cluster */
            region?: string;
            /** An unique cluster identifier */
            clusterId?: string;
          }[];
        };
      };
    };
  };
  /** Get all secrets */
  getAllSecrets: {
    responses: {
      /** Successfully obtained all secrets */
      200: {
        content: {
          "application/json": {
            secrets?: ((
              | {
                  type: "generic";
                  entries: string[];
                }
              | {
                  type: "docker-registry";
                  dockerconfig?: ".dockerconfig.json";
                }
              | {
                  type: "tls";
                  /** A Vault property name that contains PEM public key certificate */
                  crt: string;
                  /** A Vault property name that contains PEM private key certificate */
                  key: string;
                  /** A Vault property name that contains CA certificate content */
                  ca?: string;
                }
            ) & {
              id?: string;
              /** A secret name */
              name: string;
              /** A kubernetes cluster for the secret */
              clusterId: string;
            })[];
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Get services from a given team */
  getAllServices: {
    responses: {
      /** Successfully obtained all services */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A kubernetes cluster for the service */
            clusterId: string;
            port?: number;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository */
                    repository?: string;
                    tag?: string;
                  } | null;
                  secrets?:
                    | {
                        name: string;
                        entries?: string[];
                      }[]
                    | null;
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** The guaranteed amount of CPU */
                      cpu: string;
                      /** The guaranteed amount of RAM */
                      memory: string;
                    };
                    limits?: {
                      /** The maximum amount of CPU */
                      cpu: string;
                      /** The maximum amount of RAM */
                      memory: string;
                    };
                  } | null;
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | ({
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain?: string | null;
                  /** A managed DNS zone */
                  domain?: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                } | null);
            teamId: string;
          }[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Get teams collection */
  getTeams: {
    responses: {
      /** Successfully obtained teams collection */
      200: {
        content: {
          "application/json": {
            teams?: {
              id?: string;
              /** A team name */
              name: string;
              clusters: string[];
              oidc?: {
                /** An OIDC group name/id granting access to this team */
                groupMapping?: string;
              };
              password: string;
              alerts?: {
                receivers?: ("slack" | "msteams" | "email")[];
                slack?: {
                  /** Slack web hook. If none is given the global one is used. */
                  url?: string;
                  /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                  channel?: string;
                  /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                  channelCrit?: string;
                };
                msteams?: {
                  /** The low prio web hook */
                  lowPrio?: string;
                  /** The high prio web hook */
                  highPrio?: string;
                };
                email?: {
                  /** One or more email addresses (comma separated) for non-critical events. */
                  nonCritical?: string;
                  /** Email addresses (comma separated) for critical events. */
                  critical?: string;
                };
              };
              /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
              azureMonitor?: Partial<{ [key: string]: any } | null> &
                Partial<{
                  /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
                  clientId: string;
                  /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
                  clientSecret: string;
                  /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
                  logAnalyticsClientId?: string;
                  /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
                  logAnalyticsClientSecret?: string;
                  /** An app id for use with an Application Insights resource. Defaults to clientId value. */
                  appInsightsAppId?: string;
                  /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
                  appInsightsApiKey?: string;
                } | null>;
            }[];
          };
        };
      };
    };
  };
  /** Create a team */
  createTeam: {
    responses: {
      /** Successfully obtained teams collection */
      200: {
        content: {
          "application/json": {
            id?: string;
            /** A team name */
            name: string;
            clusters: string[];
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password: string;
            alerts?: {
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
              };
              msteams?: {
                /** The low prio web hook */
                lowPrio?: string;
                /** The high prio web hook */
                highPrio?: string;
              };
              email?: {
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
              };
            };
            /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
            azureMonitor?: Partial<{ [key: string]: any } | null> &
              Partial<{
                /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
                clientId: string;
                /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
                clientSecret: string;
                /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
                logAnalyticsClientId?: string;
                /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
                logAnalyticsClientSecret?: string;
                /** An app id for use with an Application Insights resource. Defaults to clientId value. */
                appInsightsAppId?: string;
                /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
                appInsightsApiKey?: string;
              } | null>;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Team object that needs to be added to the collection */
    requestBody: {
      content: {
        "application/json": {
          id?: string;
          /** A team name */
          name: string;
          clusters: string[];
          oidc?: {
            /** An OIDC group name/id granting access to this team */
            groupMapping?: string;
          };
          password: string;
          alerts?: {
            receivers?: ("slack" | "msteams" | "email")[];
            slack?: {
              /** Slack web hook. If none is given the global one is used. */
              url?: string;
              /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
              channel?: string;
              /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
              channelCrit?: string;
            };
            msteams?: {
              /** The low prio web hook */
              lowPrio?: string;
              /** The high prio web hook */
              highPrio?: string;
            };
            email?: {
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
              /** Email addresses (comma separated) for critical events. */
              critical?: string;
            };
          };
          /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
          azureMonitor?: Partial<{ [key: string]: any } | null> &
            Partial<{
              /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
              clientId: string;
              /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
              clientSecret: string;
              /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
              logAnalyticsClientId?: string;
              /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
              logAnalyticsClientSecret?: string;
              /** An app id for use with an Application Insights resource. Defaults to clientId value. */
              appInsightsAppId?: string;
              /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
              appInsightsApiKey?: string;
            } | null>;
        };
      };
    };
  };
  /** Get a specific team */
  getTeam: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully obtained team */
      200: {
        content: {
          "application/json": {
            id?: string;
            /** A team name */
            name: string;
            clusters: string[];
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password: string;
            alerts?: {
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
              };
              msteams?: {
                /** The low prio web hook */
                lowPrio?: string;
                /** The high prio web hook */
                highPrio?: string;
              };
              email?: {
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
              };
            };
            /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
            azureMonitor?: Partial<{ [key: string]: any } | null> &
              Partial<{
                /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
                clientId: string;
                /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
                clientSecret: string;
                /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
                logAnalyticsClientId?: string;
                /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
                logAnalyticsClientSecret?: string;
                /** An app id for use with an Application Insights resource. Defaults to clientId value. */
                appInsightsAppId?: string;
                /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
                appInsightsApiKey?: string;
              } | null>;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Edit a team */
  editTeam: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully edited team */
      200: {
        content: {
          "application/json": {
            id?: string;
            /** A team name */
            name: string;
            clusters: string[];
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password: string;
            alerts?: {
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
              };
              msteams?: {
                /** The low prio web hook */
                lowPrio?: string;
                /** The high prio web hook */
                highPrio?: string;
              };
              email?: {
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
              };
            };
            /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
            azureMonitor?: Partial<{ [key: string]: any } | null> &
              Partial<{
                /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
                clientId: string;
                /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
                clientSecret: string;
                /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
                logAnalyticsClientId?: string;
                /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
                logAnalyticsClientSecret?: string;
                /** An app id for use with an Application Insights resource. Defaults to clientId value. */
                appInsightsAppId?: string;
                /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
                appInsightsApiKey?: string;
              } | null>;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Team object that contains updated values */
    requestBody: {
      content: {
        "application/json": {
          id?: string;
          /** A team name */
          name: string;
          clusters: string[];
          oidc?: {
            /** An OIDC group name/id granting access to this team */
            groupMapping?: string;
          };
          password: string;
          alerts?: {
            receivers?: ("slack" | "msteams" | "email")[];
            slack?: {
              /** Slack web hook. If none is given the global one is used. */
              url?: string;
              /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
              channel?: string;
              /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
              channelCrit?: string;
            };
            msteams?: {
              /** The low prio web hook */
              lowPrio?: string;
              /** The high prio web hook */
              highPrio?: string;
            };
            email?: {
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
              /** Email addresses (comma separated) for critical events. */
              critical?: string;
            };
          };
          /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
          azureMonitor?: Partial<{ [key: string]: any } | null> &
            Partial<{
              /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
              clientId: string;
              /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
              clientSecret: string;
              /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
              logAnalyticsClientId?: string;
              /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
              logAnalyticsClientSecret?: string;
              /** An app id for use with an Application Insights resource. Defaults to clientId value. */
              appInsightsAppId?: string;
              /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
              appInsightsApiKey?: string;
            } | null>;
        };
      };
    };
  };
  /** Delete team */
  deleteTeam: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully deleted a team */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Get services from a given team */
  getTeamServices: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully obtained services */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A kubernetes cluster for the service */
            clusterId: string;
            port?: number;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository */
                    repository?: string;
                    tag?: string;
                  } | null;
                  secrets?:
                    | {
                        name: string;
                        entries?: string[];
                      }[]
                    | null;
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** The guaranteed amount of CPU */
                      cpu: string;
                      /** The guaranteed amount of RAM */
                      memory: string;
                    };
                    limits?: {
                      /** The maximum amount of CPU */
                      cpu: string;
                      /** The maximum amount of RAM */
                      memory: string;
                    };
                  } | null;
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | ({
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain?: string | null;
                  /** A managed DNS zone */
                  domain?: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                } | null);
            teamId: string;
          }[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Create a service */
  createService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully stored service configuration */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A kubernetes cluster for the service */
            clusterId: string;
            port?: number;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository */
                    repository?: string;
                    tag?: string;
                  } | null;
                  secrets?:
                    | {
                        name: string;
                        entries?: string[];
                      }[]
                    | null;
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** The guaranteed amount of CPU */
                      cpu: string;
                      /** The guaranteed amount of RAM */
                      memory: string;
                    };
                    limits?: {
                      /** The maximum amount of CPU */
                      cpu: string;
                      /** The maximum amount of RAM */
                      memory: string;
                    };
                  } | null;
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | ({
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain?: string | null;
                  /** A managed DNS zone */
                  domain?: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                } | null);
            teamId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Service object */
    requestBody: {
      content: {
        "application/json": {
          enabled?: boolean;
          id?: string;
          /** A service name */
          name: string;
          /** A kubernetes cluster for the service */
          clusterId: string;
          port?: number;
          ksvc?:
            | ({
                serviceType?: "ksvc";
                /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                scaleToZero?: boolean;
                image?: {
                  /** A container image repository */
                  repository?: string;
                  tag?: string;
                } | null;
                secrets?:
                  | {
                      name: string;
                      entries?: string[];
                    }[]
                  | null;
                env?:
                  | {
                      name: string;
                      value: string;
                    }[]
                  | null;
                resources?: {
                  requests?: {
                    /** The guaranteed amount of CPU */
                    cpu: string;
                    /** The guaranteed amount of RAM */
                    memory: string;
                  };
                  limits?: {
                    /** The maximum amount of CPU */
                    cpu: string;
                    /** The maximum amount of RAM */
                    memory: string;
                  };
                } | null;
                /** Kubernetes annotations with arbitrary metadata */
                annotations?: {
                  name?: string;
                  value?: string;
                }[];
                /** Deploys new images based on a tagging strategy */
                autoCD?:
                  | ({ [key: string]: any } | null)
                  | ({
                      tagMatcher?: "semver";
                      /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                      semver: string;
                    } | null)
                  | {
                      tagMatcher?: "glob";
                      /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                      glob: string;
                    };
              } | null)
            | {
                serviceType: "ksvcPredeployed";
              }
            | {
                serviceType: "svcPredeployed";
              };
          ingress?:
            | ({ [key: string]: any } | null)
            | ({
                /** Use the team domain so that the URL reveals the owner. */
                useDefaultSubdomain?: boolean;
                /** A host that is used to set DNS 'A' records */
                subdomain?: string | null;
                /** A managed DNS zone */
                domain?: string;
                /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                path?: string;
                /** Forward the URL path into the service (don't rewrite to /) */
                forwardPath?: boolean;
                hasSingleSignOn?: boolean;
                /** If true a certificate should exist already */
                hasCert?: boolean;
                certArn?: string;
                certSelect?: boolean;
                certName?: string;
              } | null);
          teamId: string;
        };
      };
    };
  };
  /** Get a service from a given team */
  getService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
    responses: {
      /** Successfully obtained service configuration */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A kubernetes cluster for the service */
            clusterId: string;
            port?: number;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository */
                    repository?: string;
                    tag?: string;
                  } | null;
                  secrets?:
                    | {
                        name: string;
                        entries?: string[];
                      }[]
                    | null;
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** The guaranteed amount of CPU */
                      cpu: string;
                      /** The guaranteed amount of RAM */
                      memory: string;
                    };
                    limits?: {
                      /** The maximum amount of CPU */
                      cpu: string;
                      /** The maximum amount of RAM */
                      memory: string;
                    };
                  } | null;
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | ({
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain?: string | null;
                  /** A managed DNS zone */
                  domain?: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                } | null);
            teamId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Edit a service from a given team */
  editService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
    responses: {
      /** Successfully edited service */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A service name */
            name: string;
            /** A kubernetes cluster for the service */
            clusterId: string;
            port?: number;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository */
                    repository?: string;
                    tag?: string;
                  } | null;
                  secrets?:
                    | {
                        name: string;
                        entries?: string[];
                      }[]
                    | null;
                  env?:
                    | {
                        name: string;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** The guaranteed amount of CPU */
                      cpu: string;
                      /** The guaranteed amount of RAM */
                      memory: string;
                    };
                    limits?: {
                      /** The maximum amount of CPU */
                      cpu: string;
                      /** The maximum amount of RAM */
                      memory: string;
                    };
                  } | null;
                  /** Kubernetes annotations with arbitrary metadata */
                  annotations?: {
                    name?: string;
                    value?: string;
                  }[];
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | ({
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain?: string | null;
                  /** A managed DNS zone */
                  domain?: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                } | null);
            teamId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Service object that contains updated values */
    requestBody: {
      content: {
        "application/json": {
          enabled?: boolean;
          id?: string;
          /** A service name */
          name: string;
          /** A kubernetes cluster for the service */
          clusterId: string;
          port?: number;
          ksvc?:
            | ({
                serviceType?: "ksvc";
                /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                scaleToZero?: boolean;
                image?: {
                  /** A container image repository */
                  repository?: string;
                  tag?: string;
                } | null;
                secrets?:
                  | {
                      name: string;
                      entries?: string[];
                    }[]
                  | null;
                env?:
                  | {
                      name: string;
                      value: string;
                    }[]
                  | null;
                resources?: {
                  requests?: {
                    /** The guaranteed amount of CPU */
                    cpu: string;
                    /** The guaranteed amount of RAM */
                    memory: string;
                  };
                  limits?: {
                    /** The maximum amount of CPU */
                    cpu: string;
                    /** The maximum amount of RAM */
                    memory: string;
                  };
                } | null;
                /** Kubernetes annotations with arbitrary metadata */
                annotations?: {
                  name?: string;
                  value?: string;
                }[];
                /** Deploys new images based on a tagging strategy */
                autoCD?:
                  | ({ [key: string]: any } | null)
                  | ({
                      tagMatcher?: "semver";
                      /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                      semver: string;
                    } | null)
                  | {
                      tagMatcher?: "glob";
                      /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                      glob: string;
                    };
              } | null)
            | {
                serviceType: "ksvcPredeployed";
              }
            | {
                serviceType: "svcPredeployed";
              };
          ingress?:
            | ({ [key: string]: any } | null)
            | ({
                /** Use the team domain so that the URL reveals the owner. */
                useDefaultSubdomain?: boolean;
                /** A host that is used to set DNS 'A' records */
                subdomain?: string | null;
                /** A managed DNS zone */
                domain?: string;
                /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                path?: string;
                /** Forward the URL path into the service (don't rewrite to /) */
                forwardPath?: boolean;
                hasSingleSignOn?: boolean;
                /** If true a certificate should exist already */
                hasCert?: boolean;
                certArn?: string;
                certSelect?: boolean;
                certName?: string;
              } | null);
          teamId: string;
        };
      };
    };
  };
  /** Delete a service from a given team */
  deleteService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
    responses: {
      /** Successfully deleted a service */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Get secrets from a given team */
  getSecrets: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully obtained secrets */
      200: {
        content: {
          "application/json": {
            secrets?: ((
              | {
                  type: "generic";
                  entries: string[];
                }
              | {
                  type: "docker-registry";
                  dockerconfig?: ".dockerconfig.json";
                }
              | {
                  type: "tls";
                  /** A Vault property name that contains PEM public key certificate */
                  crt: string;
                  /** A Vault property name that contains PEM private key certificate */
                  key: string;
                  /** A Vault property name that contains CA certificate content */
                  ca?: string;
                }
            ) & {
              id?: string;
              /** A secret name */
              name: string;
              /** A kubernetes cluster for the secret */
              clusterId: string;
            })[];
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Create a team secret */
  createSecret: {
    parameters: {
      path: {
        /** ID of team */
        teamId: string;
      };
    };
    responses: {
      /** Successfully stored secret configuration */
      200: {
        content: {
          "application/json": (
            | {
                type: "generic";
                entries: string[];
              }
            | {
                type: "docker-registry";
                dockerconfig?: ".dockerconfig.json";
              }
            | {
                type: "tls";
                /** A Vault property name that contains PEM public key certificate */
                crt: string;
                /** A Vault property name that contains PEM private key certificate */
                key: string;
                /** A Vault property name that contains CA certificate content */
                ca?: string;
              }
          ) & {
            id?: string;
            /** A secret name */
            name: string;
            /** A kubernetes cluster for the secret */
            clusterId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Service object */
    requestBody: {
      content: {
        "application/json": (
          | {
              type: "generic";
              entries: string[];
            }
          | {
              type: "docker-registry";
              dockerconfig?: ".dockerconfig.json";
            }
          | {
              type: "tls";
              /** A Vault property name that contains PEM public key certificate */
              crt: string;
              /** A Vault property name that contains PEM private key certificate */
              key: string;
              /** A Vault property name that contains CA certificate content */
              ca?: string;
            }
        ) & {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
        };
      };
    };
  };
  /** Get a secret from a given team */
  getSecret: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
    responses: {
      /** Successfully obtained secret configuration */
      200: {
        content: {
          "application/json": (
            | {
                type: "generic";
                entries: string[];
              }
            | {
                type: "docker-registry";
                dockerconfig?: ".dockerconfig.json";
              }
            | {
                type: "tls";
                /** A Vault property name that contains PEM public key certificate */
                crt: string;
                /** A Vault property name that contains PEM private key certificate */
                key: string;
                /** A Vault property name that contains CA certificate content */
                ca?: string;
              }
          ) & {
            id?: string;
            /** A secret name */
            name: string;
            /** A kubernetes cluster for the secret */
            clusterId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Edit a secret from a given team */
  editSecret: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
    responses: {
      /** Successfully edited a team secret */
      200: {
        content: {
          "application/json": (
            | {
                type: "generic";
                entries: string[];
              }
            | {
                type: "docker-registry";
                dockerconfig?: ".dockerconfig.json";
              }
            | {
                type: "tls";
                /** A Vault property name that contains PEM public key certificate */
                crt: string;
                /** A Vault property name that contains PEM private key certificate */
                key: string;
                /** A Vault property name that contains CA certificate content */
                ca?: string;
              }
          ) & {
            id?: string;
            /** A secret name */
            name: string;
            /** A kubernetes cluster for the secret */
            clusterId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Secret object that contains updated values */
    requestBody: {
      content: {
        "application/json": (
          | {
              type: "generic";
              entries: string[];
            }
          | {
              type: "docker-registry";
              dockerconfig?: ".dockerconfig.json";
            }
          | {
              type: "tls";
              /** A Vault property name that contains PEM public key certificate */
              crt: string;
              /** A Vault property name that contains PEM private key certificate */
              key: string;
              /** A Vault property name that contains CA certificate content */
              ca?: string;
            }
        ) & {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
        };
      };
    };
  };
  /** Delete a secret from a given team */
  deleteSecret: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
    responses: {
      /** Successfully deleted a team secret */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Trigger a deployment (only for admin) */
  deploy: {
    responses: {
      /** Deployment has been triggered */
      202: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Download a kubecfg for a team */
  downloadKubecfg: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Succesfully finished the download */
      200: {
        content: {
          "application/yaml": { [key: string]: any };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Get the session for the current user */
  getSession: {
    responses: {
      /** Get the session for the logged in user */
      200: {
        content: {
          "application/json": {
            clusters?: string[];
            core?: { [key: string]: any };
            currentClusterId?: string;
            isDirty?: boolean;
            namespaces?: string[];
            teams?: {
              id?: string;
              /** A team name */
              name: string;
              clusters: string[];
              oidc?: {
                /** An OIDC group name/id granting access to this team */
                groupMapping?: string;
              };
              password: string;
              alerts?: {
                receivers?: ("slack" | "msteams" | "email")[];
                slack?: {
                  /** Slack web hook. If none is given the global one is used. */
                  url?: string;
                  /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                  channel?: string;
                  /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                  channelCrit?: string;
                };
                msteams?: {
                  /** The low prio web hook */
                  lowPrio?: string;
                  /** The high prio web hook */
                  highPrio?: string;
                };
                email?: {
                  /** One or more email addresses (comma separated) for non-critical events. */
                  nonCritical?: string;
                  /** Email addresses (comma separated) for critical events. */
                  critical?: string;
                };
              };
              /** Azure Monitor is the platform service that provides a single source for monitoring Azure resources. */
              azureMonitor?: Partial<{ [key: string]: any } | null> &
                Partial<{
                  /** An Azure client ID (Azure Active Directory -> App Registrations -> Choose your app -> Application ID) */
                  clientId: string;
                  /** An Azure client secret (Azure Active Directory -> App Registrations -> Choose your app -> Keys -> Create a key -> Use client secret) */
                  clientSecret: string;
                  /** A dedicated client ID for Azure Log Analytics. Defaults to clientId value. */
                  logAnalyticsClientId?: string;
                  /** A client Secret for Azure Log Analytics. Defaults to clientSecret value. */
                  logAnalyticsClientSecret?: string;
                  /** An app id for use with an Application Insights resource. Defaults to clientId value. */
                  appInsightsAppId?: string;
                  /** An api key for use with an Application Insights resource. Defaults to clientSecret value. */
                  appInsightsApiKey?: string;
                } | null>;
            }[];
            user?: {
              /** A user name */
              name?: string;
              /** An email address */
              email?: string;
              /** If the user is admin */
              isAdmin?: boolean;
              /** A list of teams the user belongs to */
              teams?: string[];
              /** A list of roles that the user has */
              roles?: string[];
            };
          };
        };
      };
      /** The requested session. */
      default: unknown;
    };
  };
  /** Edits the settings from the `settings.yaml` file */
  editSettings: {
    responses: {
      /** Successfully edited `settings.yaml` */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Settings object that contains updated values */
    requestBody: {
      content: {
        "application/json": {
          /** Placeholder (copy schema from otomi-core) */
          alerts?: { [key: string]: any };
        };
      };
    };
  };
}
