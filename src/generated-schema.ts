/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/clusters": {
    /** Get available clusters */
    get: operations["getClusters"];
  };
  "/secrets": {
    /** Get all secrets */
    get: operations["getAllSecrets"];
  };
  "/services": {
    /** Get services from a given team */
    get: operations["getAllServices"];
  };
  "/teams": {
    /** Get teams collection */
    get: operations["getTeams"];
    /** Create a team */
    post: operations["createTeam"];
  };
  "/teams/{teamId}": {
    /** Get a specific team */
    get: operations["getTeam"];
    /** Edit a team */
    put: operations["editTeam"];
    /** Delete team */
    delete: operations["deleteTeam"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/teams/{teamId}/services": {
    /** Get services from a given team */
    get: operations["getTeamServices"];
    /** Create a service */
    post: operations["createService"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/teams/{teamId}/services/{serviceId}": {
    /** Get a service from a given team */
    get: operations["getService"];
    /** Edit a service from a given team */
    put: operations["editService"];
    /** Delete a service from a given team */
    delete: operations["deleteService"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
  };
  "/teams/{teamId}/secrets": {
    /** Get secrets from a given team */
    get: operations["getSecrets"];
    /** Create a team secret */
    post: operations["createSecret"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/teams/{teamId}/secrets/{secretId}": {
    /** Get a secret from a given team */
    get: operations["getSecret"];
    /** Edit a secret from a given team */
    put: operations["editSecret"];
    /** Delete a secret from a given team */
    delete: operations["deleteSecret"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
  };
  "/deploy": {
    /** Trigger a deployment (only for admin) */
    get: operations["deploy"];
  };
  "/kubecfg/{teamId}": {
    /** Download a kubecfg for a team */
    get: operations["downloadKubecfg"];
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
  };
  "/session": {
    /** Get the session for the current user */
    get: operations["getSession"];
  };
  "/apiDocs": {
    /** Get OpenAPIDoc document */
    get: operations["apiDocs"];
  };
  "/settings": {
    /** Get settings from the `settings.yaml` and `secret.settings.yaml` file. */
    get: operations["getSettings"];
    /** Edits the settings from the `settings.yaml` file */
    put: operations["editSettings"];
  };
}

export interface components {
  schemas: {
    Cloud: {
      /** A cluster name */
      name?: string;
      clusters?: {
        enabled?: boolean;
        /** A cluster name */
        name?: string;
        /** A cloud provider name */
        cloud?: string;
        /** A default cluster DNS zone */
        domain?: string;
        /** A list of DNS zones that are available to the cluster */
        dnsZones?: string[];
        /** A flag that indicates capability for deploying serverless services by using Knative */
        hasKnative?: boolean;
        /** A version of kubernetes that is installed on the cluster */
        k8sVersion?: string;
        /** A version of kubernetes that is installed on the cluster */
        otomiVersion?: string;
        /** A physical location of the cluster */
        region?: string;
        /** An unique cluster identifier */
        clusterId?: string;
      }[];
      /** A fqdn for the cloud */
      domain?: string;
    };
    Cluster: {
      enabled?: boolean;
      /** A cluster name */
      name?: string;
      /** A cloud provider name */
      cloud?: string;
      /** A default cluster DNS zone */
      domain?: string;
      /** A list of DNS zones that are available to the cluster */
      dnsZones?: string[];
      /** A flag that indicates capability for deploying serverless services by using Knative */
      hasKnative?: boolean;
      /** A version of kubernetes that is installed on the cluster */
      k8sVersion?: string;
      /** A version of kubernetes that is installed on the cluster */
      otomiVersion?: string;
      /** A physical location of the cluster */
      region?: string;
      /** An unique cluster identifier */
      clusterId?: string;
    };
    Clusters: {
      enabled?: boolean;
      /** A cluster name */
      name?: string;
      /** A cloud provider name */
      cloud?: string;
      /** A default cluster DNS zone */
      domain?: string;
      /** A list of DNS zones that are available to the cluster */
      dnsZones?: string[];
      /** A flag that indicates capability for deploying serverless services by using Knative */
      hasKnative?: boolean;
      /** A version of kubernetes that is installed on the cluster */
      k8sVersion?: string;
      /** A version of kubernetes that is installed on the cluster */
      otomiVersion?: string;
      /** A physical location of the cluster */
      region?: string;
      /** An unique cluster identifier */
      clusterId?: string;
    }[];
    Deployment: {
      id?: number;
      /** Deployment status */
      status?: "in-progress" | "completed" | "failed";
    };
    Kubecfg: { [key: string]: any };
    OpenApiValidationError: {
      status?: number;
      errors?: {
        path?: string;
        errorCode?: string;
        message?: string;
        location?: "body" | "path";
      }[];
    };
    OtomiStackError: {
      message?: string;
    };
    Secret:
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        };
    Secrets: (
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
    )[];
    Service: {
      enabled?: boolean;
      id?: string;
      /** A lowercase name that starts with a letter and may contain dashes. */
      name: string;
      /** A service port */
      port?: number;
      /** A kubernetes cluster for the service */
      clusterId: string;
      ksvc?:
        | ({
            serviceType?: "ksvc";
            /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
            scaleToZero?: boolean;
            image?: {
              /** A container image repository. */
              repository: string;
              tag: string;
            } | null;
            secrets?: {
              name: string;
              entries?: string[];
            }[];
            env?:
              | {
                  name: { [key: string]: any } | null;
                  value: string;
                }[]
              | null;
            resources?: {
              requests?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
              limits?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
            } | null;
            annotations?: { [key: string]: any };
            /** Deploys new images based on a tagging strategy */
            autoCD?:
              | ({ [key: string]: any } | null)
              | ({
                  tagMatcher?: "semver";
                  /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                  semver: string;
                } | null)
              | {
                  tagMatcher?: "glob";
                  /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                  glob: string;
                };
          } | null)
        | {
            serviceType: "ksvcPredeployed";
          }
        | {
            serviceType: "svcPredeployed";
          };
      ingress?:
        | ({ [key: string]: any } | null)
        | {
            /** Use the team domain so that the URL reveals the owner. */
            useDefaultSubdomain?: boolean;
            /** A host that is used to set DNS 'A' records */
            subdomain: string | null;
            /** A managed DNS zone */
            domain: string;
            /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
            path?: string;
            /** Forward the URL path into the service (don't rewrite to /) */
            forwardPath?: boolean;
            hasSingleSignOn?: boolean;
            /** If true a certificate should exist already */
            hasCert?: boolean;
            certArn?: string;
            certSelect?: boolean;
            certName?: string;
          };
      teamId: string;
    };
    Services: {
      enabled?: boolean;
      id?: string;
      /** A lowercase name that starts with a letter and may contain dashes. */
      name: string;
      /** A service port */
      port?: number;
      /** A kubernetes cluster for the service */
      clusterId: string;
      ksvc?:
        | ({
            serviceType?: "ksvc";
            /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
            scaleToZero?: boolean;
            image?: {
              /** A container image repository. */
              repository: string;
              tag: string;
            } | null;
            secrets?: {
              name: string;
              entries?: string[];
            }[];
            env?:
              | {
                  name: { [key: string]: any } | null;
                  value: string;
                }[]
              | null;
            resources?: {
              requests?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
              limits?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
            } | null;
            annotations?: { [key: string]: any };
            /** Deploys new images based on a tagging strategy */
            autoCD?:
              | ({ [key: string]: any } | null)
              | ({
                  tagMatcher?: "semver";
                  /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                  semver: string;
                } | null)
              | {
                  tagMatcher?: "glob";
                  /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                  glob: string;
                };
          } | null)
        | {
            serviceType: "ksvcPredeployed";
          }
        | {
            serviceType: "svcPredeployed";
          };
      ingress?:
        | ({ [key: string]: any } | null)
        | {
            /** Use the team domain so that the URL reveals the owner. */
            useDefaultSubdomain?: boolean;
            /** A host that is used to set DNS 'A' records */
            subdomain: string | null;
            /** A managed DNS zone */
            domain: string;
            /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
            path?: string;
            /** Forward the URL path into the service (don't rewrite to /) */
            forwardPath?: boolean;
            hasSingleSignOn?: boolean;
            /** If true a certificate should exist already */
            hasCert?: boolean;
            certArn?: string;
            certSelect?: boolean;
            certName?: string;
          };
      teamId: string;
    }[];
    Session: {
      clusters?: string[];
      core?: { [key: string]: any };
      currentClusterId?: string;
      isDirty?: boolean;
      namespaces?: string[];
      teams?: {
        /** A lowercase name that starts with a letter and may contain dashes. */
        id?: string;
        /** A lowercase name that starts with a letter and may contain dashes. */
        name: string;
        clusters: string[];
        oidc?: {
          /** An OIDC group name/id granting access to this team */
          groupMapping?: string;
        };
        password: string;
        alerts?: {
          receivers?: ("slack" | "msteams" | "email")[];
          slack?: {
            /** Slack web hook. If none is given the global one is used. */
            url?: string;
            /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
            channel?: string;
            /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
            channelCrit?: string;
          };
          msteams?: {
            /** The low prio web hook */
            lowPrio?: string;
            /** The high prio web hook */
            highPrio?: string;
          };
          email?: {
            /** One or more email addresses (comma separated) for non-critical events. */
            nonCritical?: string;
            /** Email addresses (comma separated) for critical events. */
            critical?: string;
          };
        };
        azureMonitor?: {
          /** An Azure AppInsights client secret (defaults to clientSecret). */
          appInsightsApiKey?: string;
          /** An Azure AppInsights client id (defaults to clientId). */
          appInsightsAppId?: string;
          /** An Azure client id. */
          clientId?: string;
          /** An Azure client secret. */
          clientSecret?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientId?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientSecret?: string;
          /** An Azure tenant id (defaults to tenantId). */
          logAnalyticsTenantId?: string;
          /** An Azure monitor log analytics workspace. */
          logAnalyticsWorkspace?: string;
        };
      }[];
      user?: {
        /** A user name */
        name: string;
        email: string;
        /** If the user is admin */
        isAdmin: boolean;
        /** A list of teams the user belongs to */
        teams: string[];
        /** A list of roles that the user has */
        roles: string[];
      };
    };
    Settings: {
      alerts?: {
        drone?: "slack" | "msteams";
        email?: {
          /** One or more email addresses (comma separated) for critical events. */
          critical?: string;
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
        };
        /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
        groupInterval?: string;
        msteams?: {
          /** The low prio web hook. */
          highPrio?: string;
          /** The high prio web hook. */
          lowPrio?: string;
        };
        /** Notification receivers. */
        receivers?: ("slack" | "msteams" | "email")[];
        /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
        repeatInterval?: string;
        slack?: {
          /** The Slack channel for non-critical notifications. */
          channel?: string;
          /** The Slack channel for critical notifications. */
          channelCrit?: string;
          /** A Slack webhook URL. */
          url?: string;
        };
      };
      /** Azure specific configuration. */
      azure?: {
        appgw?: {
          /** Is this appgw installed as AKS addon? */
          isManaged?: boolean;
        };
        /** An Azure disk type (SKU Type). */
        diskType:
          | "Standard_LRS"
          | "Standard_GRS"
          | "Standard_RAGRS"
          | "Standard_ZRS"
          | "Premium_LRS"
          | "Premium_ZRS"
          | "Standard_GZRS"
          | "Standard_RAGZRS";
        /** Azure Key Vault access credentials. Will use azure.tenantId if tenantId is not provided. */
        keyVault?: {
          /** An Azure tenant ID. */
          tenantId?: string;
          /** An Azure client ID. */
          clientId: string;
          /** An Azure client secret. */
          clientSecret: string;
        };
        monitor?: {
          /** An Azure AppInsights client secret (defaults to clientSecret). */
          appInsightsApiKey?: string;
          /** An Azure AppInsights client id (defaults to clientId). */
          appInsightsAppId?: string;
          /** An Azure client id. */
          clientId?: string;
          /** An Azure client secret. */
          clientSecret?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientId?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientSecret?: string;
          /** An Azure tenant id (defaults to tenantId). */
          logAnalyticsTenantId?: string;
          /** An Azure monitor log analytics workspace. */
          logAnalyticsWorkspace?: string;
        };
        /** An Azure resource group. */
        resourceGroup: string;
        /** An Azure subscription ID. */
        subscriptionId: string;
        /** An Azure tenant ID. */
        tenantId: string;
      };
      customer?: {
        name?: string;
      };
      /** Google specific configuration. */
      google?: {
        /** A service account key for managing a DNS zone. */
        cloudDnsKey: string;
        /** A service account key for managing a KMS vault. */
        kmsAccount?: string;
        /** A Google Cloud project ID for accessing DNS zone. */
        projectId: string;
      };
      home?: {
        drone?: "slack" | "msteams";
        email?: {
          /** One or more email addresses (comma separated) for critical events. */
          critical?: string;
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
        };
        /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
        groupInterval?: string;
        msteams?: {
          /** The low prio web hook. */
          highPrio?: string;
          /** The high prio web hook. */
          lowPrio?: string;
        };
        /** Notification receivers. */
        receivers?: ("slack" | "msteams" | "email")[];
        /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
        repeatInterval?: string;
        slack?: {
          /** The Slack channel for non-critical notifications. */
          channel?: string;
          /** The Slack channel for critical notifications. */
          channelCrit?: string;
          /** A Slack webhook URL. */
          url?: string;
        };
      };
      /** Use Cloud KMS to encrypt and decrypt the master key */
      kms?:
        | {
            gcpckms: {
              project: string;
              region: string;
              key_ring: string;
              kmsAccount: string;
            };
          }
        | {
            awskms: {
              region: string;
              access_key: string;
              secret_key: string;
              endpoint: string;
            };
          }
        | {
            azurekeyvault: {
              vault_name: string;
              tenant_id: string;
              client_id: string;
              client_secret: string;
            };
          };
      /** Holds many parts used in different locations. Please see keycloak, istio and oauth-proxy all consuming parts. */
      oidc?: {
        adminGroupID?: string;
        apiUrl?: string;
        authUrl?: string;
        clientID?: string;
        clientSecret?: string;
        issuer?: string;
        scope?: string;
        teamAdminGroupID?: string;
        tenantID?: string;
        tokenUrl?: string;
        /** Claim name used by Keycloak to identify incoming users from identity provider */
        usernameClaimMapper?: string;
        /** Select OIDC claim to be used as a unique user identifier */
        subClaimMapper?: string;
      };
      otomi?: {
        /** Set this to true when an external LB exists or needs to be started (AWS ALB, Azure AppGW, Google Apigee). This will then be configured through ingress controllers. Expects existing LBs to terminate https. Currently this is only working correctly for Azure, and not for AWS and Google. AWS is close to completion. */
        hasCloudLB?: boolean;
        /** Whether this cluster is home monitored (like when under a Premium SLA). Sends criticals home. */
        isHomeMonitored?: boolean;
        /** Whether masters are managed and not under control. Set this to false when onprem. */
        isManaged?: boolean;
        /** Whether to separate team metrics and logs. Disabling this lets everybody be admin and see everything. */
        isMultitenant?: boolean;
        /** The otomi-core edition. Either community edition (ce) or enterprise edition (ee). */
        mode?: "ce" | "ee";
        /** The pullsecret to deploy the Otomi API and Console. Requires an Otomi license. */
        pullSecret?: string;
        /** The prefix to use in URLs for team domains. */
        teamPrefix?: string;
        /** Manage addon configuration */
        addons?: {
          conftest?: {
            /** Use this flag to enable conftest for policy validation */
            enabled?: boolean;
          };
        };
      };
      smtp?: {
        auth_identity?: string;
        auth_password?: string;
        auth_secret?: string;
        auth_username?: string;
        /** The "from" address. Defaults to alerts@$clusterDomain. */
        from?: string;
        hello?: string;
        /** The smtp host:port combination. */
        smarthost: string;
      };
    };
    Team: {
      /** A lowercase name that starts with a letter and may contain dashes. */
      id?: string;
      /** A lowercase name that starts with a letter and may contain dashes. */
      name: string;
      clusters: string[];
      oidc?: {
        /** An OIDC group name/id granting access to this team */
        groupMapping?: string;
      };
      password: string;
      alerts?: {
        receivers?: ("slack" | "msteams" | "email")[];
        slack?: {
          /** Slack web hook. If none is given the global one is used. */
          url?: string;
          /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
          channel?: string;
          /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
          channelCrit?: string;
        };
        msteams?: {
          /** The low prio web hook */
          lowPrio?: string;
          /** The high prio web hook */
          highPrio?: string;
        };
        email?: {
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
          /** Email addresses (comma separated) for critical events. */
          critical?: string;
        };
      };
      azureMonitor?: {
        /** An Azure AppInsights client secret (defaults to clientSecret). */
        appInsightsApiKey?: string;
        /** An Azure AppInsights client id (defaults to clientId). */
        appInsightsAppId?: string;
        /** An Azure client id. */
        clientId?: string;
        /** An Azure client secret. */
        clientSecret?: string;
        /** An Azure client secret (defaults to clientSecret). */
        logAnalyticsClientId?: string;
        /** An Azure client secret (defaults to clientSecret). */
        logAnalyticsClientSecret?: string;
        /** An Azure tenant id (defaults to tenantId). */
        logAnalyticsTenantId?: string;
        /** An Azure monitor log analytics workspace. */
        logAnalyticsWorkspace?: string;
      };
    };
    Teams: {
      /** A lowercase name that starts with a letter and may contain dashes. */
      id?: string;
      /** A lowercase name that starts with a letter and may contain dashes. */
      name: string;
      clusters: string[];
      oidc?: {
        /** An OIDC group name/id granting access to this team */
        groupMapping?: string;
      };
      password: string;
      alerts?: {
        receivers?: ("slack" | "msteams" | "email")[];
        slack?: {
          /** Slack web hook. If none is given the global one is used. */
          url?: string;
          /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
          channel?: string;
          /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
          channelCrit?: string;
        };
        msteams?: {
          /** The low prio web hook */
          lowPrio?: string;
          /** The high prio web hook */
          highPrio?: string;
        };
        email?: {
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
          /** Email addresses (comma separated) for critical events. */
          critical?: string;
        };
      };
      azureMonitor?: {
        /** An Azure AppInsights client secret (defaults to clientSecret). */
        appInsightsApiKey?: string;
        /** An Azure AppInsights client id (defaults to clientId). */
        appInsightsAppId?: string;
        /** An Azure client id. */
        clientId?: string;
        /** An Azure client secret. */
        clientSecret?: string;
        /** An Azure client secret (defaults to clientSecret). */
        logAnalyticsClientId?: string;
        /** An Azure client secret (defaults to clientSecret). */
        logAnalyticsClientSecret?: string;
        /** An Azure tenant id (defaults to tenantId). */
        logAnalyticsTenantId?: string;
        /** An Azure monitor log analytics workspace. */
        logAnalyticsWorkspace?: string;
      };
    }[];
    User: {
      /** A user name */
      name: string;
      email: string;
      /** If the user is admin */
      isAdmin: boolean;
      /** A list of teams the user belongs to */
      teams: string[];
      /** A list of roles that the user has */
      roles: string[];
    };
    SecretGeneric: {
      id?: string;
      /** A secret name */
      name: string;
      /** A kubernetes cluster for the secret */
      clusterId: string;
      type?: "generic" | "docker-registry" | "tls";
    };
    SecretDocker: {
      id?: string;
      /** A secret name */
      name: string;
      /** A kubernetes cluster for the secret */
      clusterId: string;
      type?: "generic" | "docker-registry" | "tls";
    };
    SecretTLS: {
      id?: string;
      /** A secret name */
      name: string;
      /** A kubernetes cluster for the secret */
      clusterId: string;
      type?: "generic" | "docker-registry" | "tls";
    };
    cluster_Cluster: {
      enabled?: boolean;
      /** A cluster name */
      name?: string;
      /** A cloud provider name */
      cloud?: string;
      /** A default cluster DNS zone */
      domain?: string;
      /** A list of DNS zones that are available to the cluster */
      dnsZones?: string[];
      /** A flag that indicates capability for deploying serverless services by using Knative */
      hasKnative?: boolean;
      /** A version of kubernetes that is installed on the cluster */
      k8sVersion?: string;
      /** A version of kubernetes that is installed on the cluster */
      otomiVersion?: string;
      /** A physical location of the cluster */
      region?: string;
      /** An unique cluster identifier */
      clusterId?: string;
    };
    clusters_Clusters: {
      enabled?: boolean;
      /** A cluster name */
      name?: string;
      /** A cloud provider name */
      cloud?: string;
      /** A default cluster DNS zone */
      domain?: string;
      /** A list of DNS zones that are available to the cluster */
      dnsZones?: string[];
      /** A flag that indicates capability for deploying serverless services by using Knative */
      hasKnative?: boolean;
      /** A version of kubernetes that is installed on the cluster */
      k8sVersion?: string;
      /** A version of kubernetes that is installed on the cluster */
      otomiVersion?: string;
      /** A physical location of the cluster */
      region?: string;
      /** An unique cluster identifier */
      clusterId?: string;
    }[];
    shared: {
      id?: string;
      /** A secret name */
      name: string;
      /** A kubernetes cluster for the secret */
      clusterId: string;
      type?: "generic" | "docker-registry" | "tls";
    };
    secret_Secret:
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        };
    secrets_Secrets: (
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
      | {
          id?: string;
          /** A secret name */
          name: string;
          /** A kubernetes cluster for the secret */
          clusterId: string;
          type?: "generic" | "docker-registry" | "tls";
        }
    )[];
    error_OpenApiValidationError: {
      status?: number;
      errors?: {
        path?: string;
        errorCode?: string;
        message?: string;
        location?: "body" | "path";
      }[];
    };
    /** A lowercase name that starts with a letter and may contain dashes. */
    idName: string;
    /** A container image repository. */
    repository: string;
    env: { [key: string]: any } | null;
    /** Amount of cores, or slice of cpu in millis. */
    cpuQuantity: string;
    /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
    memoryQuantity: string;
    labelsAnnotations: { [key: string]: any };
    domain: string;
    service_Service: {
      enabled?: boolean;
      id?: string;
      /** A lowercase name that starts with a letter and may contain dashes. */
      name: string;
      /** A service port */
      port?: number;
      /** A kubernetes cluster for the service */
      clusterId: string;
      ksvc?:
        | ({
            serviceType?: "ksvc";
            /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
            scaleToZero?: boolean;
            image?: {
              /** A container image repository. */
              repository: string;
              tag: string;
            } | null;
            secrets?: {
              name: string;
              entries?: string[];
            }[];
            env?:
              | {
                  name: { [key: string]: any } | null;
                  value: string;
                }[]
              | null;
            resources?: {
              requests?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
              limits?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
            } | null;
            annotations?: { [key: string]: any };
            /** Deploys new images based on a tagging strategy */
            autoCD?:
              | ({ [key: string]: any } | null)
              | ({
                  tagMatcher?: "semver";
                  /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                  semver: string;
                } | null)
              | {
                  tagMatcher?: "glob";
                  /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                  glob: string;
                };
          } | null)
        | {
            serviceType: "ksvcPredeployed";
          }
        | {
            serviceType: "svcPredeployed";
          };
      ingress?:
        | ({ [key: string]: any } | null)
        | {
            /** Use the team domain so that the URL reveals the owner. */
            useDefaultSubdomain?: boolean;
            /** A host that is used to set DNS 'A' records */
            subdomain: string | null;
            /** A managed DNS zone */
            domain: string;
            /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
            path?: string;
            /** Forward the URL path into the service (don't rewrite to /) */
            forwardPath?: boolean;
            hasSingleSignOn?: boolean;
            /** If true a certificate should exist already */
            hasCert?: boolean;
            certArn?: string;
            certSelect?: boolean;
            certName?: string;
          };
      teamId: string;
    };
    services_Services: {
      enabled?: boolean;
      id?: string;
      /** A lowercase name that starts with a letter and may contain dashes. */
      name: string;
      /** A service port */
      port?: number;
      /** A kubernetes cluster for the service */
      clusterId: string;
      ksvc?:
        | ({
            serviceType?: "ksvc";
            /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
            scaleToZero?: boolean;
            image?: {
              /** A container image repository. */
              repository: string;
              tag: string;
            } | null;
            secrets?: {
              name: string;
              entries?: string[];
            }[];
            env?:
              | {
                  name: { [key: string]: any } | null;
                  value: string;
                }[]
              | null;
            resources?: {
              requests?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
              limits?: {
                /** Amount of cores, or slice of cpu in millis. */
                cpu: string;
                /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                memory: string;
              };
            } | null;
            annotations?: { [key: string]: any };
            /** Deploys new images based on a tagging strategy */
            autoCD?:
              | ({ [key: string]: any } | null)
              | ({
                  tagMatcher?: "semver";
                  /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                  semver: string;
                } | null)
              | {
                  tagMatcher?: "glob";
                  /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                  glob: string;
                };
          } | null)
        | {
            serviceType: "ksvcPredeployed";
          }
        | {
            serviceType: "svcPredeployed";
          };
      ingress?:
        | ({ [key: string]: any } | null)
        | {
            /** Use the team domain so that the URL reveals the owner. */
            useDefaultSubdomain?: boolean;
            /** A host that is used to set DNS 'A' records */
            subdomain: string | null;
            /** A managed DNS zone */
            domain: string;
            /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
            path?: string;
            /** Forward the URL path into the service (don't rewrite to /) */
            forwardPath?: boolean;
            hasSingleSignOn?: boolean;
            /** If true a certificate should exist already */
            hasCert?: boolean;
            certArn?: string;
            certSelect?: boolean;
            certName?: string;
          };
      teamId: string;
    }[];
    azureMonitor: {
      /** An Azure AppInsights client secret (defaults to clientSecret). */
      appInsightsApiKey?: string;
      /** An Azure AppInsights client id (defaults to clientId). */
      appInsightsAppId?: string;
      /** An Azure client id. */
      clientId?: string;
      /** An Azure client secret. */
      clientSecret?: string;
      /** An Azure client secret (defaults to clientSecret). */
      logAnalyticsClientId?: string;
      /** An Azure client secret (defaults to clientSecret). */
      logAnalyticsClientSecret?: string;
      /** An Azure tenant id (defaults to tenantId). */
      logAnalyticsTenantId?: string;
      /** An Azure monitor log analytics workspace. */
      logAnalyticsWorkspace?: string;
    };
    team_Team: {
      /** A lowercase name that starts with a letter and may contain dashes. */
      id?: string;
      /** A lowercase name that starts with a letter and may contain dashes. */
      name: string;
      clusters: string[];
      oidc?: {
        /** An OIDC group name/id granting access to this team */
        groupMapping?: string;
      };
      password: string;
      alerts?: {
        receivers?: ("slack" | "msteams" | "email")[];
        slack?: {
          /** Slack web hook. If none is given the global one is used. */
          url?: string;
          /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
          channel?: string;
          /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
          channelCrit?: string;
        };
        msteams?: {
          /** The low prio web hook */
          lowPrio?: string;
          /** The high prio web hook */
          highPrio?: string;
        };
        email?: {
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
          /** Email addresses (comma separated) for critical events. */
          critical?: string;
        };
      };
      azureMonitor?: {
        /** An Azure AppInsights client secret (defaults to clientSecret). */
        appInsightsApiKey?: string;
        /** An Azure AppInsights client id (defaults to clientId). */
        appInsightsAppId?: string;
        /** An Azure client id. */
        clientId?: string;
        /** An Azure client secret. */
        clientSecret?: string;
        /** An Azure client secret (defaults to clientSecret). */
        logAnalyticsClientId?: string;
        /** An Azure client secret (defaults to clientSecret). */
        logAnalyticsClientSecret?: string;
        /** An Azure tenant id (defaults to tenantId). */
        logAnalyticsTenantId?: string;
        /** An Azure monitor log analytics workspace. */
        logAnalyticsWorkspace?: string;
      };
    };
    teams_Teams: {
      /** A lowercase name that starts with a letter and may contain dashes. */
      id?: string;
      /** A lowercase name that starts with a letter and may contain dashes. */
      name: string;
      clusters: string[];
      oidc?: {
        /** An OIDC group name/id granting access to this team */
        groupMapping?: string;
      };
      password: string;
      alerts?: {
        receivers?: ("slack" | "msteams" | "email")[];
        slack?: {
          /** Slack web hook. If none is given the global one is used. */
          url?: string;
          /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
          channel?: string;
          /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
          channelCrit?: string;
        };
        msteams?: {
          /** The low prio web hook */
          lowPrio?: string;
          /** The high prio web hook */
          highPrio?: string;
        };
        email?: {
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
          /** Email addresses (comma separated) for critical events. */
          critical?: string;
        };
      };
      azureMonitor?: {
        /** An Azure AppInsights client secret (defaults to clientSecret). */
        appInsightsApiKey?: string;
        /** An Azure AppInsights client id (defaults to clientId). */
        appInsightsAppId?: string;
        /** An Azure client id. */
        clientId?: string;
        /** An Azure client secret. */
        clientSecret?: string;
        /** An Azure client secret (defaults to clientSecret). */
        logAnalyticsClientId?: string;
        /** An Azure client secret (defaults to clientSecret). */
        logAnalyticsClientSecret?: string;
        /** An Azure tenant id (defaults to tenantId). */
        logAnalyticsTenantId?: string;
        /** An Azure monitor log analytics workspace. */
        logAnalyticsWorkspace?: string;
      };
    }[];
    error_OtomiStackError: {
      message?: string;
    };
    email: string;
    user_User: {
      /** A user name */
      name: string;
      email: string;
      /** If the user is admin */
      isAdmin: boolean;
      /** A list of teams the user belongs to */
      teams: string[];
      /** A list of roles that the user has */
      roles: string[];
    };
    session_Session: {
      clusters?: string[];
      core?: { [key: string]: any };
      currentClusterId?: string;
      isDirty?: boolean;
      namespaces?: string[];
      teams?: {
        /** A lowercase name that starts with a letter and may contain dashes. */
        id?: string;
        /** A lowercase name that starts with a letter and may contain dashes. */
        name: string;
        clusters: string[];
        oidc?: {
          /** An OIDC group name/id granting access to this team */
          groupMapping?: string;
        };
        password: string;
        alerts?: {
          receivers?: ("slack" | "msteams" | "email")[];
          slack?: {
            /** Slack web hook. If none is given the global one is used. */
            url?: string;
            /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
            channel?: string;
            /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
            channelCrit?: string;
          };
          msteams?: {
            /** The low prio web hook */
            lowPrio?: string;
            /** The high prio web hook */
            highPrio?: string;
          };
          email?: {
            /** One or more email addresses (comma separated) for non-critical events. */
            nonCritical?: string;
            /** Email addresses (comma separated) for critical events. */
            critical?: string;
          };
        };
        azureMonitor?: {
          /** An Azure AppInsights client secret (defaults to clientSecret). */
          appInsightsApiKey?: string;
          /** An Azure AppInsights client id (defaults to clientId). */
          appInsightsAppId?: string;
          /** An Azure client id. */
          clientId?: string;
          /** An Azure client secret. */
          clientSecret?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientId?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientSecret?: string;
          /** An Azure tenant id (defaults to tenantId). */
          logAnalyticsTenantId?: string;
          /** An Azure monitor log analytics workspace. */
          logAnalyticsWorkspace?: string;
        };
      }[];
      user?: {
        /** A user name */
        name: string;
        email: string;
        /** If the user is admin */
        isAdmin: boolean;
        /** A list of teams the user belongs to */
        teams: string[];
        /** A list of roles that the user has */
        roles: string[];
      };
    };
    url: string;
    alerts: {
      drone?: "slack" | "msteams";
      email?: {
        /** One or more email addresses (comma separated) for critical events. */
        critical?: string;
        /** One or more email addresses (comma separated) for non-critical events. */
        nonCritical?: string;
      };
      /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
      groupInterval?: string;
      msteams?: {
        /** The low prio web hook. */
        highPrio?: string;
        /** The high prio web hook. */
        lowPrio?: string;
      };
      /** Notification receivers. */
      receivers?: ("slack" | "msteams" | "email")[];
      /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
      repeatInterval?: string;
      slack?: {
        /** The Slack channel for non-critical notifications. */
        channel?: string;
        /** The Slack channel for critical notifications. */
        channelCrit?: string;
        /** A Slack webhook URL. */
        url?: string;
      };
    };
    hostPort: string;
    settings_Settings: {
      alerts?: {
        drone?: "slack" | "msteams";
        email?: {
          /** One or more email addresses (comma separated) for critical events. */
          critical?: string;
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
        };
        /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
        groupInterval?: string;
        msteams?: {
          /** The low prio web hook. */
          highPrio?: string;
          /** The high prio web hook. */
          lowPrio?: string;
        };
        /** Notification receivers. */
        receivers?: ("slack" | "msteams" | "email")[];
        /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
        repeatInterval?: string;
        slack?: {
          /** The Slack channel for non-critical notifications. */
          channel?: string;
          /** The Slack channel for critical notifications. */
          channelCrit?: string;
          /** A Slack webhook URL. */
          url?: string;
        };
      };
      /** Azure specific configuration. */
      azure?: {
        appgw?: {
          /** Is this appgw installed as AKS addon? */
          isManaged?: boolean;
        };
        /** An Azure disk type (SKU Type). */
        diskType:
          | "Standard_LRS"
          | "Standard_GRS"
          | "Standard_RAGRS"
          | "Standard_ZRS"
          | "Premium_LRS"
          | "Premium_ZRS"
          | "Standard_GZRS"
          | "Standard_RAGZRS";
        /** Azure Key Vault access credentials. Will use azure.tenantId if tenantId is not provided. */
        keyVault?: {
          /** An Azure tenant ID. */
          tenantId?: string;
          /** An Azure client ID. */
          clientId: string;
          /** An Azure client secret. */
          clientSecret: string;
        };
        monitor?: {
          /** An Azure AppInsights client secret (defaults to clientSecret). */
          appInsightsApiKey?: string;
          /** An Azure AppInsights client id (defaults to clientId). */
          appInsightsAppId?: string;
          /** An Azure client id. */
          clientId?: string;
          /** An Azure client secret. */
          clientSecret?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientId?: string;
          /** An Azure client secret (defaults to clientSecret). */
          logAnalyticsClientSecret?: string;
          /** An Azure tenant id (defaults to tenantId). */
          logAnalyticsTenantId?: string;
          /** An Azure monitor log analytics workspace. */
          logAnalyticsWorkspace?: string;
        };
        /** An Azure resource group. */
        resourceGroup: string;
        /** An Azure subscription ID. */
        subscriptionId: string;
        /** An Azure tenant ID. */
        tenantId: string;
      };
      customer?: {
        name?: string;
      };
      /** Google specific configuration. */
      google?: {
        /** A service account key for managing a DNS zone. */
        cloudDnsKey: string;
        /** A service account key for managing a KMS vault. */
        kmsAccount?: string;
        /** A Google Cloud project ID for accessing DNS zone. */
        projectId: string;
      };
      home?: {
        drone?: "slack" | "msteams";
        email?: {
          /** One or more email addresses (comma separated) for critical events. */
          critical?: string;
          /** One or more email addresses (comma separated) for non-critical events. */
          nonCritical?: string;
        };
        /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
        groupInterval?: string;
        msteams?: {
          /** The low prio web hook. */
          highPrio?: string;
          /** The high prio web hook. */
          lowPrio?: string;
        };
        /** Notification receivers. */
        receivers?: ("slack" | "msteams" | "email")[];
        /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
        repeatInterval?: string;
        slack?: {
          /** The Slack channel for non-critical notifications. */
          channel?: string;
          /** The Slack channel for critical notifications. */
          channelCrit?: string;
          /** A Slack webhook URL. */
          url?: string;
        };
      };
      /** Use Cloud KMS to encrypt and decrypt the master key */
      kms?:
        | {
            gcpckms: {
              project: string;
              region: string;
              key_ring: string;
              kmsAccount: string;
            };
          }
        | {
            awskms: {
              region: string;
              access_key: string;
              secret_key: string;
              endpoint: string;
            };
          }
        | {
            azurekeyvault: {
              vault_name: string;
              tenant_id: string;
              client_id: string;
              client_secret: string;
            };
          };
      /** Holds many parts used in different locations. Please see keycloak, istio and oauth-proxy all consuming parts. */
      oidc?: {
        adminGroupID?: string;
        apiUrl?: string;
        authUrl?: string;
        clientID?: string;
        clientSecret?: string;
        issuer?: string;
        scope?: string;
        teamAdminGroupID?: string;
        tenantID?: string;
        tokenUrl?: string;
        /** Claim name used by Keycloak to identify incoming users from identity provider */
        usernameClaimMapper?: string;
        /** Select OIDC claim to be used as a unique user identifier */
        subClaimMapper?: string;
      };
      otomi?: {
        /** Set this to true when an external LB exists or needs to be started (AWS ALB, Azure AppGW, Google Apigee). This will then be configured through ingress controllers. Expects existing LBs to terminate https. Currently this is only working correctly for Azure, and not for AWS and Google. AWS is close to completion. */
        hasCloudLB?: boolean;
        /** Whether this cluster is home monitored (like when under a Premium SLA). Sends criticals home. */
        isHomeMonitored?: boolean;
        /** Whether masters are managed and not under control. Set this to false when onprem. */
        isManaged?: boolean;
        /** Whether to separate team metrics and logs. Disabling this lets everybody be admin and see everything. */
        isMultitenant?: boolean;
        /** The otomi-core edition. Either community edition (ce) or enterprise edition (ee). */
        mode?: "ce" | "ee";
        /** The pullsecret to deploy the Otomi API and Console. Requires an Otomi license. */
        pullSecret?: string;
        /** The prefix to use in URLs for team domains. */
        teamPrefix?: string;
        /** Manage addon configuration */
        addons?: {
          conftest?: {
            /** Use this flag to enable conftest for policy validation */
            enabled?: boolean;
          };
        };
      };
      smtp?: {
        auth_identity?: string;
        auth_password?: string;
        auth_secret?: string;
        auth_username?: string;
        /** The "from" address. Defaults to alerts@$clusterDomain. */
        from?: string;
        hello?: string;
        /** The smtp host:port combination. */
        smarthost: string;
      };
    };
    cloud_Cloud: {
      /** A cluster name */
      name?: string;
      clusters?: {
        enabled?: boolean;
        /** A cluster name */
        name?: string;
        /** A cloud provider name */
        cloud?: string;
        /** A default cluster DNS zone */
        domain?: string;
        /** A list of DNS zones that are available to the cluster */
        dnsZones?: string[];
        /** A flag that indicates capability for deploying serverless services by using Knative */
        hasKnative?: boolean;
        /** A version of kubernetes that is installed on the cluster */
        k8sVersion?: string;
        /** A version of kubernetes that is installed on the cluster */
        otomiVersion?: string;
        /** A physical location of the cluster */
        region?: string;
        /** An unique cluster identifier */
        clusterId?: string;
      }[];
      /** A fqdn for the cloud */
      domain?: string;
    };
    deployment_Deployment: {
      id?: number;
      /** Deployment status */
      status?: "in-progress" | "completed" | "failed";
    };
    kubecfg_Kubecfg: { [key: string]: any };
  };
  parameters: {
    /** ID of team to return */
    teamParams: string;
    /** ID of the service */
    serviceParams: string;
    /** ID of the secret */
    secretParams: string;
  };
}

export interface operations {
  /** Get available clusters */
  getClusters: {
    responses: {
      /** Successfully obtained cluster collection */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            /** A cluster name */
            name?: string;
            /** A cloud provider name */
            cloud?: string;
            /** A default cluster DNS zone */
            domain?: string;
            /** A list of DNS zones that are available to the cluster */
            dnsZones?: string[];
            /** A flag that indicates capability for deploying serverless services by using Knative */
            hasKnative?: boolean;
            /** A version of kubernetes that is installed on the cluster */
            k8sVersion?: string;
            /** A version of kubernetes that is installed on the cluster */
            otomiVersion?: string;
            /** A physical location of the cluster */
            region?: string;
            /** An unique cluster identifier */
            clusterId?: string;
          }[];
        };
      };
    };
  };
  /** Get all secrets */
  getAllSecrets: {
    responses: {
      /** Successfully obtained all secrets */
      200: {
        content: {
          "application/json": (
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
          )[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Get services from a given team */
  getAllServices: {
    responses: {
      /** Successfully obtained all services */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A lowercase name that starts with a letter and may contain dashes. */
            name: string;
            /** A service port */
            port?: number;
            /** A kubernetes cluster for the service */
            clusterId: string;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  env?:
                    | {
                        name: { [key: string]: any } | null;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  } | null;
                  annotations?: { [key: string]: any };
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          }[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Get teams collection */
  getTeams: {
    responses: {
      /** Successfully obtained teams collection */
      200: {
        content: {
          "application/json": {
            /** A lowercase name that starts with a letter and may contain dashes. */
            id?: string;
            /** A lowercase name that starts with a letter and may contain dashes. */
            name: string;
            clusters: string[];
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password: string;
            alerts?: {
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
              };
              msteams?: {
                /** The low prio web hook */
                lowPrio?: string;
                /** The high prio web hook */
                highPrio?: string;
              };
              email?: {
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
              };
            };
            azureMonitor?: {
              /** An Azure AppInsights client secret (defaults to clientSecret). */
              appInsightsApiKey?: string;
              /** An Azure AppInsights client id (defaults to clientId). */
              appInsightsAppId?: string;
              /** An Azure client id. */
              clientId?: string;
              /** An Azure client secret. */
              clientSecret?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientId?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientSecret?: string;
              /** An Azure tenant id (defaults to tenantId). */
              logAnalyticsTenantId?: string;
              /** An Azure monitor log analytics workspace. */
              logAnalyticsWorkspace?: string;
            };
          }[];
        };
      };
    };
  };
  /** Create a team */
  createTeam: {
    responses: {
      /** Successfully obtained teams collection */
      200: {
        content: {
          "application/json": {
            /** A lowercase name that starts with a letter and may contain dashes. */
            id?: string;
            /** A lowercase name that starts with a letter and may contain dashes. */
            name: string;
            clusters: string[];
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password: string;
            alerts?: {
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
              };
              msteams?: {
                /** The low prio web hook */
                lowPrio?: string;
                /** The high prio web hook */
                highPrio?: string;
              };
              email?: {
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
              };
            };
            azureMonitor?: {
              /** An Azure AppInsights client secret (defaults to clientSecret). */
              appInsightsApiKey?: string;
              /** An Azure AppInsights client id (defaults to clientId). */
              appInsightsAppId?: string;
              /** An Azure client id. */
              clientId?: string;
              /** An Azure client secret. */
              clientSecret?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientId?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientSecret?: string;
              /** An Azure tenant id (defaults to tenantId). */
              logAnalyticsTenantId?: string;
              /** An Azure monitor log analytics workspace. */
              logAnalyticsWorkspace?: string;
            };
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Team object that needs to be added to the collection */
    requestBody: {
      content: {
        "application/json": {
          /** A lowercase name that starts with a letter and may contain dashes. */
          id?: string;
          /** A lowercase name that starts with a letter and may contain dashes. */
          name: string;
          clusters: string[];
          oidc?: {
            /** An OIDC group name/id granting access to this team */
            groupMapping?: string;
          };
          password: string;
          alerts?: {
            receivers?: ("slack" | "msteams" | "email")[];
            slack?: {
              /** Slack web hook. If none is given the global one is used. */
              url?: string;
              /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
              channel?: string;
              /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
              channelCrit?: string;
            };
            msteams?: {
              /** The low prio web hook */
              lowPrio?: string;
              /** The high prio web hook */
              highPrio?: string;
            };
            email?: {
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
              /** Email addresses (comma separated) for critical events. */
              critical?: string;
            };
          };
          azureMonitor?: {
            /** An Azure AppInsights client secret (defaults to clientSecret). */
            appInsightsApiKey?: string;
            /** An Azure AppInsights client id (defaults to clientId). */
            appInsightsAppId?: string;
            /** An Azure client id. */
            clientId?: string;
            /** An Azure client secret. */
            clientSecret?: string;
            /** An Azure client secret (defaults to clientSecret). */
            logAnalyticsClientId?: string;
            /** An Azure client secret (defaults to clientSecret). */
            logAnalyticsClientSecret?: string;
            /** An Azure tenant id (defaults to tenantId). */
            logAnalyticsTenantId?: string;
            /** An Azure monitor log analytics workspace. */
            logAnalyticsWorkspace?: string;
          };
        };
      };
    };
  };
  /** Get a specific team */
  getTeam: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully obtained team */
      200: {
        content: {
          "application/json": {
            /** A lowercase name that starts with a letter and may contain dashes. */
            id?: string;
            /** A lowercase name that starts with a letter and may contain dashes. */
            name: string;
            clusters: string[];
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password: string;
            alerts?: {
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
              };
              msteams?: {
                /** The low prio web hook */
                lowPrio?: string;
                /** The high prio web hook */
                highPrio?: string;
              };
              email?: {
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
              };
            };
            azureMonitor?: {
              /** An Azure AppInsights client secret (defaults to clientSecret). */
              appInsightsApiKey?: string;
              /** An Azure AppInsights client id (defaults to clientId). */
              appInsightsAppId?: string;
              /** An Azure client id. */
              clientId?: string;
              /** An Azure client secret. */
              clientSecret?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientId?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientSecret?: string;
              /** An Azure tenant id (defaults to tenantId). */
              logAnalyticsTenantId?: string;
              /** An Azure monitor log analytics workspace. */
              logAnalyticsWorkspace?: string;
            };
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Edit a team */
  editTeam: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully edited team */
      200: {
        content: {
          "application/json": {
            /** A lowercase name that starts with a letter and may contain dashes. */
            id?: string;
            /** A lowercase name that starts with a letter and may contain dashes. */
            name: string;
            clusters: string[];
            oidc?: {
              /** An OIDC group name/id granting access to this team */
              groupMapping?: string;
            };
            password: string;
            alerts?: {
              receivers?: ("slack" | "msteams" | "email")[];
              slack?: {
                /** Slack web hook. If none is given the global one is used. */
                url?: string;
                /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                channel?: string;
                /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                channelCrit?: string;
              };
              msteams?: {
                /** The low prio web hook */
                lowPrio?: string;
                /** The high prio web hook */
                highPrio?: string;
              };
              email?: {
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
                /** Email addresses (comma separated) for critical events. */
                critical?: string;
              };
            };
            azureMonitor?: {
              /** An Azure AppInsights client secret (defaults to clientSecret). */
              appInsightsApiKey?: string;
              /** An Azure AppInsights client id (defaults to clientId). */
              appInsightsAppId?: string;
              /** An Azure client id. */
              clientId?: string;
              /** An Azure client secret. */
              clientSecret?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientId?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientSecret?: string;
              /** An Azure tenant id (defaults to tenantId). */
              logAnalyticsTenantId?: string;
              /** An Azure monitor log analytics workspace. */
              logAnalyticsWorkspace?: string;
            };
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Team object that contains updated values */
    requestBody: {
      content: {
        "application/json": {
          /** A lowercase name that starts with a letter and may contain dashes. */
          id?: string;
          /** A lowercase name that starts with a letter and may contain dashes. */
          name: string;
          clusters: string[];
          oidc?: {
            /** An OIDC group name/id granting access to this team */
            groupMapping?: string;
          };
          password: string;
          alerts?: {
            receivers?: ("slack" | "msteams" | "email")[];
            slack?: {
              /** Slack web hook. If none is given the global one is used. */
              url?: string;
              /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
              channel?: string;
              /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
              channelCrit?: string;
            };
            msteams?: {
              /** The low prio web hook */
              lowPrio?: string;
              /** The high prio web hook */
              highPrio?: string;
            };
            email?: {
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
              /** Email addresses (comma separated) for critical events. */
              critical?: string;
            };
          };
          azureMonitor?: {
            /** An Azure AppInsights client secret (defaults to clientSecret). */
            appInsightsApiKey?: string;
            /** An Azure AppInsights client id (defaults to clientId). */
            appInsightsAppId?: string;
            /** An Azure client id. */
            clientId?: string;
            /** An Azure client secret. */
            clientSecret?: string;
            /** An Azure client secret (defaults to clientSecret). */
            logAnalyticsClientId?: string;
            /** An Azure client secret (defaults to clientSecret). */
            logAnalyticsClientSecret?: string;
            /** An Azure tenant id (defaults to tenantId). */
            logAnalyticsTenantId?: string;
            /** An Azure monitor log analytics workspace. */
            logAnalyticsWorkspace?: string;
          };
        };
      };
    };
  };
  /** Delete team */
  deleteTeam: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully deleted a team */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Get services from a given team */
  getTeamServices: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully obtained services */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A lowercase name that starts with a letter and may contain dashes. */
            name: string;
            /** A service port */
            port?: number;
            /** A kubernetes cluster for the service */
            clusterId: string;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  env?:
                    | {
                        name: { [key: string]: any } | null;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  } | null;
                  annotations?: { [key: string]: any };
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          }[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Create a service */
  createService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully stored service configuration */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A lowercase name that starts with a letter and may contain dashes. */
            name: string;
            /** A service port */
            port?: number;
            /** A kubernetes cluster for the service */
            clusterId: string;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  env?:
                    | {
                        name: { [key: string]: any } | null;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  } | null;
                  annotations?: { [key: string]: any };
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Service object */
    requestBody: {
      content: {
        "application/json": {
          enabled?: boolean;
          id?: string;
          /** A lowercase name that starts with a letter and may contain dashes. */
          name: string;
          /** A service port */
          port?: number;
          /** A kubernetes cluster for the service */
          clusterId: string;
          ksvc?:
            | ({
                serviceType?: "ksvc";
                /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                scaleToZero?: boolean;
                image?: {
                  /** A container image repository. */
                  repository: string;
                  tag: string;
                } | null;
                secrets?: {
                  name: string;
                  entries?: string[];
                }[];
                env?:
                  | {
                      name: { [key: string]: any } | null;
                      value: string;
                    }[]
                  | null;
                resources?: {
                  requests?: {
                    /** Amount of cores, or slice of cpu in millis. */
                    cpu: string;
                    /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                    memory: string;
                  };
                  limits?: {
                    /** Amount of cores, or slice of cpu in millis. */
                    cpu: string;
                    /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                    memory: string;
                  };
                } | null;
                annotations?: { [key: string]: any };
                /** Deploys new images based on a tagging strategy */
                autoCD?:
                  | ({ [key: string]: any } | null)
                  | ({
                      tagMatcher?: "semver";
                      /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                      semver: string;
                    } | null)
                  | {
                      tagMatcher?: "glob";
                      /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                      glob: string;
                    };
              } | null)
            | {
                serviceType: "ksvcPredeployed";
              }
            | {
                serviceType: "svcPredeployed";
              };
          ingress?:
            | ({ [key: string]: any } | null)
            | {
                /** Use the team domain so that the URL reveals the owner. */
                useDefaultSubdomain?: boolean;
                /** A host that is used to set DNS 'A' records */
                subdomain: string | null;
                /** A managed DNS zone */
                domain: string;
                /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                path?: string;
                /** Forward the URL path into the service (don't rewrite to /) */
                forwardPath?: boolean;
                hasSingleSignOn?: boolean;
                /** If true a certificate should exist already */
                hasCert?: boolean;
                certArn?: string;
                certSelect?: boolean;
                certName?: string;
              };
          teamId: string;
        };
      };
    };
  };
  /** Get a service from a given team */
  getService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
    responses: {
      /** Successfully obtained service configuration */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A lowercase name that starts with a letter and may contain dashes. */
            name: string;
            /** A service port */
            port?: number;
            /** A kubernetes cluster for the service */
            clusterId: string;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  env?:
                    | {
                        name: { [key: string]: any } | null;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  } | null;
                  annotations?: { [key: string]: any };
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Edit a service from a given team */
  editService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
    responses: {
      /** Successfully edited service */
      200: {
        content: {
          "application/json": {
            enabled?: boolean;
            id?: string;
            /** A lowercase name that starts with a letter and may contain dashes. */
            name: string;
            /** A service port */
            port?: number;
            /** A kubernetes cluster for the service */
            clusterId: string;
            ksvc?:
              | ({
                  serviceType?: "ksvc";
                  /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                  scaleToZero?: boolean;
                  image?: {
                    /** A container image repository. */
                    repository: string;
                    tag: string;
                  } | null;
                  secrets?: {
                    name: string;
                    entries?: string[];
                  }[];
                  env?:
                    | {
                        name: { [key: string]: any } | null;
                        value: string;
                      }[]
                    | null;
                  resources?: {
                    requests?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                    limits?: {
                      /** Amount of cores, or slice of cpu in millis. */
                      cpu: string;
                      /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                      memory: string;
                    };
                  } | null;
                  annotations?: { [key: string]: any };
                  /** Deploys new images based on a tagging strategy */
                  autoCD?:
                    | ({ [key: string]: any } | null)
                    | ({
                        tagMatcher?: "semver";
                        /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                        semver: string;
                      } | null)
                    | {
                        tagMatcher?: "glob";
                        /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                        glob: string;
                      };
                } | null)
              | {
                  serviceType: "ksvcPredeployed";
                }
              | {
                  serviceType: "svcPredeployed";
                };
            ingress?:
              | ({ [key: string]: any } | null)
              | {
                  /** Use the team domain so that the URL reveals the owner. */
                  useDefaultSubdomain?: boolean;
                  /** A host that is used to set DNS 'A' records */
                  subdomain: string | null;
                  /** A managed DNS zone */
                  domain: string;
                  /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                  path?: string;
                  /** Forward the URL path into the service (don't rewrite to /) */
                  forwardPath?: boolean;
                  hasSingleSignOn?: boolean;
                  /** If true a certificate should exist already */
                  hasCert?: boolean;
                  certArn?: string;
                  certSelect?: boolean;
                  certName?: string;
                };
            teamId: string;
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Service object that contains updated values */
    requestBody: {
      content: {
        "application/json": {
          enabled?: boolean;
          id?: string;
          /** A lowercase name that starts with a letter and may contain dashes. */
          name: string;
          /** A service port */
          port?: number;
          /** A kubernetes cluster for the service */
          clusterId: string;
          ksvc?:
            | ({
                serviceType?: "ksvc";
                /** Scales to zero after 60 seconds and needs approximately 8 seconds to start back up. */
                scaleToZero?: boolean;
                image?: {
                  /** A container image repository. */
                  repository: string;
                  tag: string;
                } | null;
                secrets?: {
                  name: string;
                  entries?: string[];
                }[];
                env?:
                  | {
                      name: { [key: string]: any } | null;
                      value: string;
                    }[]
                  | null;
                resources?: {
                  requests?: {
                    /** Amount of cores, or slice of cpu in millis. */
                    cpu: string;
                    /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                    memory: string;
                  };
                  limits?: {
                    /** Amount of cores, or slice of cpu in millis. */
                    cpu: string;
                    /** Amount of memory. Valid units are E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki. */
                    memory: string;
                  };
                } | null;
                annotations?: { [key: string]: any };
                /** Deploys new images based on a tagging strategy */
                autoCD?:
                  | ({ [key: string]: any } | null)
                  | ({
                      tagMatcher?: "semver";
                      /** Use this filter if your image tags follow semantic versioning rules (MAJOR.MINOR.PATCH). E.g.: PATCH only: "~1.1", MINOR and PATCH only "~1", ALL "*" */
                      semver: string;
                    } | null)
                  | {
                      tagMatcher?: "glob";
                      /** Use this filter if you want to make glob-style patterns. E.g.: "main-v1.3.*" */
                      glob: string;
                    };
              } | null)
            | {
                serviceType: "ksvcPredeployed";
              }
            | {
                serviceType: "svcPredeployed";
              };
          ingress?:
            | ({ [key: string]: any } | null)
            | {
                /** Use the team domain so that the URL reveals the owner. */
                useDefaultSubdomain?: boolean;
                /** A host that is used to set DNS 'A' records */
                subdomain: string | null;
                /** A managed DNS zone */
                domain: string;
                /** The path in the URL that the service should be mapped to (e.g. for microservices on one app/domain.) */
                path?: string;
                /** Forward the URL path into the service (don't rewrite to /) */
                forwardPath?: boolean;
                hasSingleSignOn?: boolean;
                /** If true a certificate should exist already */
                hasCert?: boolean;
                certArn?: string;
                certSelect?: boolean;
                certName?: string;
              };
          teamId: string;
        };
      };
    };
  };
  /** Delete a service from a given team */
  deleteService: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the service */
        serviceId: string;
      };
    };
    responses: {
      /** Successfully deleted a service */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Get secrets from a given team */
  getSecrets: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Successfully obtained secrets */
      200: {
        content: {
          "application/json": (
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
          )[];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
    };
  };
  /** Create a team secret */
  createSecret: {
    parameters: {
      path: {
        /** ID of team */
        teamId: string;
      };
    };
    responses: {
      /** Successfully stored secret configuration */
      200: {
        content: {
          "application/json":
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Service object */
    requestBody: {
      content: {
        "application/json":
          | {
              id?: string;
              /** A secret name */
              name: string;
              /** A kubernetes cluster for the secret */
              clusterId: string;
              type?: "generic" | "docker-registry" | "tls";
            }
          | {
              id?: string;
              /** A secret name */
              name: string;
              /** A kubernetes cluster for the secret */
              clusterId: string;
              type?: "generic" | "docker-registry" | "tls";
            }
          | {
              id?: string;
              /** A secret name */
              name: string;
              /** A kubernetes cluster for the secret */
              clusterId: string;
              type?: "generic" | "docker-registry" | "tls";
            };
      };
    };
  };
  /** Get a secret from a given team */
  getSecret: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
    responses: {
      /** Successfully obtained secret configuration */
      200: {
        content: {
          "application/json":
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Edit a secret from a given team */
  editSecret: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
    responses: {
      /** Successfully edited a team secret */
      200: {
        content: {
          "application/json":
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              }
            | {
                id?: string;
                /** A secret name */
                name: string;
                /** A kubernetes cluster for the secret */
                clusterId: string;
                type?: "generic" | "docker-registry" | "tls";
              };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Secret object that contains updated values */
    requestBody: {
      content: {
        "application/json":
          | {
              id?: string;
              /** A secret name */
              name: string;
              /** A kubernetes cluster for the secret */
              clusterId: string;
              type?: "generic" | "docker-registry" | "tls";
            }
          | {
              id?: string;
              /** A secret name */
              name: string;
              /** A kubernetes cluster for the secret */
              clusterId: string;
              type?: "generic" | "docker-registry" | "tls";
            }
          | {
              id?: string;
              /** A secret name */
              name: string;
              /** A kubernetes cluster for the secret */
              clusterId: string;
              type?: "generic" | "docker-registry" | "tls";
            };
      };
    };
  };
  /** Delete a secret from a given team */
  deleteSecret: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
        /** ID of the secret */
        secretId: string;
      };
    };
    responses: {
      /** Successfully deleted a team secret */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Trigger a deployment (only for admin) */
  deploy: {
    responses: {
      /** Deployment has been triggered */
      202: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Resource already exists */
      409: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Download a kubecfg for a team */
  downloadKubecfg: {
    parameters: {
      path: {
        /** ID of team to return */
        teamId: string;
      };
    };
    responses: {
      /** Succesfully finished the download */
      200: {
        content: {
          "application/yaml": { [key: string]: any };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
  };
  /** Get the session for the current user */
  getSession: {
    responses: {
      /** Get the session for the logged in user */
      200: {
        content: {
          "application/json": {
            clusters?: string[];
            core?: { [key: string]: any };
            currentClusterId?: string;
            isDirty?: boolean;
            namespaces?: string[];
            teams?: {
              /** A lowercase name that starts with a letter and may contain dashes. */
              id?: string;
              /** A lowercase name that starts with a letter and may contain dashes. */
              name: string;
              clusters: string[];
              oidc?: {
                /** An OIDC group name/id granting access to this team */
                groupMapping?: string;
              };
              password: string;
              alerts?: {
                receivers?: ("slack" | "msteams" | "email")[];
                slack?: {
                  /** Slack web hook. If none is given the global one is used. */
                  url?: string;
                  /** Slack channel for non-criticals. If none is given the global one is used, which defaults to 'mon-otomi'. */
                  channel?: string;
                  /** Slack channel for critical alerts. If none is given the global one is used, which defaults to 'mon-otomi-crit'. */
                  channelCrit?: string;
                };
                msteams?: {
                  /** The low prio web hook */
                  lowPrio?: string;
                  /** The high prio web hook */
                  highPrio?: string;
                };
                email?: {
                  /** One or more email addresses (comma separated) for non-critical events. */
                  nonCritical?: string;
                  /** Email addresses (comma separated) for critical events. */
                  critical?: string;
                };
              };
              azureMonitor?: {
                /** An Azure AppInsights client secret (defaults to clientSecret). */
                appInsightsApiKey?: string;
                /** An Azure AppInsights client id (defaults to clientId). */
                appInsightsAppId?: string;
                /** An Azure client id. */
                clientId?: string;
                /** An Azure client secret. */
                clientSecret?: string;
                /** An Azure client secret (defaults to clientSecret). */
                logAnalyticsClientId?: string;
                /** An Azure client secret (defaults to clientSecret). */
                logAnalyticsClientSecret?: string;
                /** An Azure tenant id (defaults to tenantId). */
                logAnalyticsTenantId?: string;
                /** An Azure monitor log analytics workspace. */
                logAnalyticsWorkspace?: string;
              };
            }[];
            user?: {
              /** A user name */
              name: string;
              email: string;
              /** If the user is admin */
              isAdmin: boolean;
              /** A list of teams the user belongs to */
              teams: string[];
              /** A list of roles that the user has */
              roles: string[];
            };
          };
        };
      };
      /** The requested session. */
      default: unknown;
    };
  };
  /** Get OpenAPIDoc document */
  apiDocs: {
    responses: {
      /** The requested apiDoc. */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** The requested apiDoc. */
      default: unknown;
    };
  };
  /** Get settings from the `settings.yaml` and `secret.settings.yaml` file. */
  getSettings: {
    responses: {
      /** The request is successful. */
      200: {
        content: {
          "application/json": {
            alerts?: {
              drone?: "slack" | "msteams";
              email?: {
                /** One or more email addresses (comma separated) for critical events. */
                critical?: string;
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
              };
              /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
              groupInterval?: string;
              msteams?: {
                /** The low prio web hook. */
                highPrio?: string;
                /** The high prio web hook. */
                lowPrio?: string;
              };
              /** Notification receivers. */
              receivers?: ("slack" | "msteams" | "email")[];
              /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
              repeatInterval?: string;
              slack?: {
                /** The Slack channel for non-critical notifications. */
                channel?: string;
                /** The Slack channel for critical notifications. */
                channelCrit?: string;
                /** A Slack webhook URL. */
                url?: string;
              };
            };
            /** Azure specific configuration. */
            azure?: {
              appgw?: {
                /** Is this appgw installed as AKS addon? */
                isManaged?: boolean;
              };
              /** An Azure disk type (SKU Type). */
              diskType:
                | "Standard_LRS"
                | "Standard_GRS"
                | "Standard_RAGRS"
                | "Standard_ZRS"
                | "Premium_LRS"
                | "Premium_ZRS"
                | "Standard_GZRS"
                | "Standard_RAGZRS";
              /** Azure Key Vault access credentials. Will use azure.tenantId if tenantId is not provided. */
              keyVault?: {
                /** An Azure tenant ID. */
                tenantId?: string;
                /** An Azure client ID. */
                clientId: string;
                /** An Azure client secret. */
                clientSecret: string;
              };
              monitor?: {
                /** An Azure AppInsights client secret (defaults to clientSecret). */
                appInsightsApiKey?: string;
                /** An Azure AppInsights client id (defaults to clientId). */
                appInsightsAppId?: string;
                /** An Azure client id. */
                clientId?: string;
                /** An Azure client secret. */
                clientSecret?: string;
                /** An Azure client secret (defaults to clientSecret). */
                logAnalyticsClientId?: string;
                /** An Azure client secret (defaults to clientSecret). */
                logAnalyticsClientSecret?: string;
                /** An Azure tenant id (defaults to tenantId). */
                logAnalyticsTenantId?: string;
                /** An Azure monitor log analytics workspace. */
                logAnalyticsWorkspace?: string;
              };
              /** An Azure resource group. */
              resourceGroup: string;
              /** An Azure subscription ID. */
              subscriptionId: string;
              /** An Azure tenant ID. */
              tenantId: string;
            };
            customer?: {
              name?: string;
            };
            /** Google specific configuration. */
            google?: {
              /** A service account key for managing a DNS zone. */
              cloudDnsKey: string;
              /** A service account key for managing a KMS vault. */
              kmsAccount?: string;
              /** A Google Cloud project ID for accessing DNS zone. */
              projectId: string;
            };
            home?: {
              drone?: "slack" | "msteams";
              email?: {
                /** One or more email addresses (comma separated) for critical events. */
                critical?: string;
                /** One or more email addresses (comma separated) for non-critical events. */
                nonCritical?: string;
              };
              /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
              groupInterval?: string;
              msteams?: {
                /** The low prio web hook. */
                highPrio?: string;
                /** The high prio web hook. */
                lowPrio?: string;
              };
              /** Notification receivers. */
              receivers?: ("slack" | "msteams" | "email")[];
              /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
              repeatInterval?: string;
              slack?: {
                /** The Slack channel for non-critical notifications. */
                channel?: string;
                /** The Slack channel for critical notifications. */
                channelCrit?: string;
                /** A Slack webhook URL. */
                url?: string;
              };
            };
            /** Use Cloud KMS to encrypt and decrypt the master key */
            kms?:
              | {
                  gcpckms: {
                    project: string;
                    region: string;
                    key_ring: string;
                    kmsAccount: string;
                  };
                }
              | {
                  awskms: {
                    region: string;
                    access_key: string;
                    secret_key: string;
                    endpoint: string;
                  };
                }
              | {
                  azurekeyvault: {
                    vault_name: string;
                    tenant_id: string;
                    client_id: string;
                    client_secret: string;
                  };
                };
            /** Holds many parts used in different locations. Please see keycloak, istio and oauth-proxy all consuming parts. */
            oidc?: {
              adminGroupID?: string;
              apiUrl?: string;
              authUrl?: string;
              clientID?: string;
              clientSecret?: string;
              issuer?: string;
              scope?: string;
              teamAdminGroupID?: string;
              tenantID?: string;
              tokenUrl?: string;
              /** Claim name used by Keycloak to identify incoming users from identity provider */
              usernameClaimMapper?: string;
              /** Select OIDC claim to be used as a unique user identifier */
              subClaimMapper?: string;
            };
            otomi?: {
              /** Set this to true when an external LB exists or needs to be started (AWS ALB, Azure AppGW, Google Apigee). This will then be configured through ingress controllers. Expects existing LBs to terminate https. Currently this is only working correctly for Azure, and not for AWS and Google. AWS is close to completion. */
              hasCloudLB?: boolean;
              /** Whether this cluster is home monitored (like when under a Premium SLA). Sends criticals home. */
              isHomeMonitored?: boolean;
              /** Whether masters are managed and not under control. Set this to false when onprem. */
              isManaged?: boolean;
              /** Whether to separate team metrics and logs. Disabling this lets everybody be admin and see everything. */
              isMultitenant?: boolean;
              /** The otomi-core edition. Either community edition (ce) or enterprise edition (ee). */
              mode?: "ce" | "ee";
              /** The pullsecret to deploy the Otomi API and Console. Requires an Otomi license. */
              pullSecret?: string;
              /** The prefix to use in URLs for team domains. */
              teamPrefix?: string;
              /** Manage addon configuration */
              addons?: {
                conftest?: {
                  /** Use this flag to enable conftest for policy validation */
                  enabled?: boolean;
                };
              };
            };
            smtp?: {
              auth_identity?: string;
              auth_password?: string;
              auth_secret?: string;
              auth_username?: string;
              /** The "from" address. Defaults to alerts@$clusterDomain. */
              from?: string;
              hello?: string;
              /** The smtp host:port combination. */
              smarthost: string;
            };
          };
        };
      };
    };
  };
  /** Edits the settings from the `settings.yaml` file */
  editSettings: {
    responses: {
      /** Successfully edited `settings.yaml` */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "application/json": {
            status?: number;
            errors?: {
              path?: string;
              errorCode?: string;
              message?: string;
              location?: "body" | "path";
            }[];
          };
        };
      };
      /** Resource does not exist */
      404: {
        content: {
          "application/json": {
            message?: string;
          };
        };
      };
    };
    /** Settings object that contains updated values */
    requestBody: {
      content: {
        "application/json": {
          alerts?: {
            drone?: "slack" | "msteams";
            email?: {
              /** One or more email addresses (comma separated) for critical events. */
              critical?: string;
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
            };
            /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
            groupInterval?: string;
            msteams?: {
              /** The low prio web hook. */
              highPrio?: string;
              /** The high prio web hook. */
              lowPrio?: string;
            };
            /** Notification receivers. */
            receivers?: ("slack" | "msteams" | "email")[];
            /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
            repeatInterval?: string;
            slack?: {
              /** The Slack channel for non-critical notifications. */
              channel?: string;
              /** The Slack channel for critical notifications. */
              channelCrit?: string;
              /** A Slack webhook URL. */
              url?: string;
            };
          };
          /** Azure specific configuration. */
          azure?: {
            appgw?: {
              /** Is this appgw installed as AKS addon? */
              isManaged?: boolean;
            };
            /** An Azure disk type (SKU Type). */
            diskType:
              | "Standard_LRS"
              | "Standard_GRS"
              | "Standard_RAGRS"
              | "Standard_ZRS"
              | "Premium_LRS"
              | "Premium_ZRS"
              | "Standard_GZRS"
              | "Standard_RAGZRS";
            /** Azure Key Vault access credentials. Will use azure.tenantId if tenantId is not provided. */
            keyVault?: {
              /** An Azure tenant ID. */
              tenantId?: string;
              /** An Azure client ID. */
              clientId: string;
              /** An Azure client secret. */
              clientSecret: string;
            };
            monitor?: {
              /** An Azure AppInsights client secret (defaults to clientSecret). */
              appInsightsApiKey?: string;
              /** An Azure AppInsights client id (defaults to clientId). */
              appInsightsAppId?: string;
              /** An Azure client id. */
              clientId?: string;
              /** An Azure client secret. */
              clientSecret?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientId?: string;
              /** An Azure client secret (defaults to clientSecret). */
              logAnalyticsClientSecret?: string;
              /** An Azure tenant id (defaults to tenantId). */
              logAnalyticsTenantId?: string;
              /** An Azure monitor log analytics workspace. */
              logAnalyticsWorkspace?: string;
            };
            /** An Azure resource group. */
            resourceGroup: string;
            /** An Azure subscription ID. */
            subscriptionId: string;
            /** An Azure tenant ID. */
            tenantId: string;
          };
          customer?: {
            name?: string;
          };
          /** Google specific configuration. */
          google?: {
            /** A service account key for managing a DNS zone. */
            cloudDnsKey: string;
            /** A service account key for managing a KMS vault. */
            kmsAccount?: string;
            /** A Google Cloud project ID for accessing DNS zone. */
            projectId: string;
          };
          home?: {
            drone?: "slack" | "msteams";
            email?: {
              /** One or more email addresses (comma separated) for critical events. */
              critical?: string;
              /** One or more email addresses (comma separated) for non-critical events. */
              nonCritical?: string;
            };
            /** How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) */
            groupInterval?: string;
            msteams?: {
              /** The low prio web hook. */
              highPrio?: string;
              /** The high prio web hook. */
              lowPrio?: string;
            };
            /** Notification receivers. */
            receivers?: ("slack" | "msteams" | "email")[];
            /** How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). */
            repeatInterval?: string;
            slack?: {
              /** The Slack channel for non-critical notifications. */
              channel?: string;
              /** The Slack channel for critical notifications. */
              channelCrit?: string;
              /** A Slack webhook URL. */
              url?: string;
            };
          };
          /** Use Cloud KMS to encrypt and decrypt the master key */
          kms?:
            | {
                gcpckms: {
                  project: string;
                  region: string;
                  key_ring: string;
                  kmsAccount: string;
                };
              }
            | {
                awskms: {
                  region: string;
                  access_key: string;
                  secret_key: string;
                  endpoint: string;
                };
              }
            | {
                azurekeyvault: {
                  vault_name: string;
                  tenant_id: string;
                  client_id: string;
                  client_secret: string;
                };
              };
          /** Holds many parts used in different locations. Please see keycloak, istio and oauth-proxy all consuming parts. */
          oidc?: {
            adminGroupID?: string;
            apiUrl?: string;
            authUrl?: string;
            clientID?: string;
            clientSecret?: string;
            issuer?: string;
            scope?: string;
            teamAdminGroupID?: string;
            tenantID?: string;
            tokenUrl?: string;
            /** Claim name used by Keycloak to identify incoming users from identity provider */
            usernameClaimMapper?: string;
            /** Select OIDC claim to be used as a unique user identifier */
            subClaimMapper?: string;
          };
          otomi?: {
            /** Set this to true when an external LB exists or needs to be started (AWS ALB, Azure AppGW, Google Apigee). This will then be configured through ingress controllers. Expects existing LBs to terminate https. Currently this is only working correctly for Azure, and not for AWS and Google. AWS is close to completion. */
            hasCloudLB?: boolean;
            /** Whether this cluster is home monitored (like when under a Premium SLA). Sends criticals home. */
            isHomeMonitored?: boolean;
            /** Whether masters are managed and not under control. Set this to false when onprem. */
            isManaged?: boolean;
            /** Whether to separate team metrics and logs. Disabling this lets everybody be admin and see everything. */
            isMultitenant?: boolean;
            /** The otomi-core edition. Either community edition (ce) or enterprise edition (ee). */
            mode?: "ce" | "ee";
            /** The pullsecret to deploy the Otomi API and Console. Requires an Otomi license. */
            pullSecret?: string;
            /** The prefix to use in URLs for team domains. */
            teamPrefix?: string;
            /** Manage addon configuration */
            addons?: {
              conftest?: {
                /** Use this flag to enable conftest for policy validation */
                enabled?: boolean;
              };
            };
          };
          smtp?: {
            auth_identity?: string;
            auth_password?: string;
            auth_secret?: string;
            auth_username?: string;
            /** The "from" address. Defaults to alerts@$clusterDomain. */
            from?: string;
            hello?: string;
            /** The smtp host:port combination. */
            smarthost: string;
          };
        };
      };
    };
  };
}
